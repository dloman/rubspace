// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protos/subspace.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:subspace.InitRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InitRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.InitRequest.client_name)
    pub client_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.InitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InitRequest {
    fn default() -> &'a InitRequest {
        <InitRequest as ::protobuf::Message>::default_instance()
    }
}

impl InitRequest {
    pub fn new() -> InitRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_name",
            |m: &InitRequest| { &m.client_name },
            |m: &mut InitRequest| { &mut m.client_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitRequest>(
            "InitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InitRequest {
    const NAME: &'static str = "InitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_name.is_empty() {
            os.write_string(1, &self.client_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InitRequest {
        InitRequest::new()
    }

    fn clear(&mut self) {
        self.client_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InitRequest {
        static instance: InitRequest = InitRequest {
            client_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  All Request and Response messages are carried over a Unix Domain
///  Socket between the client and the server.  They are followed
///  by an array of file descriptors (SCM_RIGHTS message) that
///  are duped from the server.  These fds are for shared memory
///  segments and trigger fds.  The messages contain indices into
///  the fd array.
// @@protoc_insertion_point(message:subspace.InitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InitResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.InitResponse.scb_fd_index)
    pub scb_fd_index: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.InitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InitResponse {
    fn default() -> &'a InitResponse {
        <InitResponse as ::protobuf::Message>::default_instance()
    }
}

impl InitResponse {
    pub fn new() -> InitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scb_fd_index",
            |m: &InitResponse| { &m.scb_fd_index },
            |m: &mut InitResponse| { &mut m.scb_fd_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitResponse>(
            "InitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InitResponse {
    const NAME: &'static str = "InitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scb_fd_index = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.scb_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.scb_fd_index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.scb_fd_index != 0 {
            os.write_int32(1, self.scb_fd_index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InitResponse {
        InitResponse::new()
    }

    fn clear(&mut self) {
        self.scb_fd_index = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InitResponse {
        static instance: InitResponse = InitResponse {
            scb_fd_index: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.BufferInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BufferInfo {
    // message fields
    // @@protoc_insertion_point(field:subspace.BufferInfo.slot_size)
    pub slot_size: i32,
    // @@protoc_insertion_point(field:subspace.BufferInfo.fd_index)
    pub fd_index: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.BufferInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BufferInfo {
    fn default() -> &'a BufferInfo {
        <BufferInfo as ::protobuf::Message>::default_instance()
    }
}

impl BufferInfo {
    pub fn new() -> BufferInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &BufferInfo| { &m.slot_size },
            |m: &mut BufferInfo| { &mut m.slot_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fd_index",
            |m: &BufferInfo| { &m.fd_index },
            |m: &mut BufferInfo| { &mut m.fd_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BufferInfo>(
            "BufferInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BufferInfo {
    const NAME: &'static str = "BufferInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot_size = is.read_int32()?;
                },
                16 => {
                    self.fd_index = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.slot_size);
        }
        if self.fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.fd_index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot_size != 0 {
            os.write_int32(1, self.slot_size)?;
        }
        if self.fd_index != 0 {
            os.write_int32(2, self.fd_index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BufferInfo {
        BufferInfo::new()
    }

    fn clear(&mut self) {
        self.slot_size = 0;
        self.fd_index = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BufferInfo {
        static instance: BufferInfo = BufferInfo {
            slot_size: 0,
            fd_index: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BufferInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BufferInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BufferInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.CreatePublisherRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreatePublisherRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.num_slots)
    pub num_slots: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.slot_size)
    pub slot_size: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.is_local)
    pub is_local: bool,
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.is_reliable)
    pub is_reliable: bool,
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.is_bridge)
    pub is_bridge: bool,
    // @@protoc_insertion_point(field:subspace.CreatePublisherRequest.type)
    pub type_: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.CreatePublisherRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatePublisherRequest {
    fn default() -> &'a CreatePublisherRequest {
        <CreatePublisherRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePublisherRequest {
    pub fn new() -> CreatePublisherRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &CreatePublisherRequest| { &m.channel_name },
            |m: &mut CreatePublisherRequest| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_slots",
            |m: &CreatePublisherRequest| { &m.num_slots },
            |m: &mut CreatePublisherRequest| { &mut m.num_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &CreatePublisherRequest| { &m.slot_size },
            |m: &mut CreatePublisherRequest| { &mut m.slot_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_local",
            |m: &CreatePublisherRequest| { &m.is_local },
            |m: &mut CreatePublisherRequest| { &mut m.is_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_reliable",
            |m: &CreatePublisherRequest| { &m.is_reliable },
            |m: &mut CreatePublisherRequest| { &mut m.is_reliable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bridge",
            |m: &CreatePublisherRequest| { &m.is_bridge },
            |m: &mut CreatePublisherRequest| { &mut m.is_bridge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CreatePublisherRequest| { &m.type_ },
            |m: &mut CreatePublisherRequest| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreatePublisherRequest>(
            "CreatePublisherRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreatePublisherRequest {
    const NAME: &'static str = "CreatePublisherRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.num_slots = is.read_int32()?;
                },
                24 => {
                    self.slot_size = is.read_int32()?;
                },
                32 => {
                    self.is_local = is.read_bool()?;
                },
                40 => {
                    self.is_reliable = is.read_bool()?;
                },
                48 => {
                    self.is_bridge = is.read_bool()?;
                },
                58 => {
                    self.type_ = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.num_slots != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.num_slots);
        }
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.slot_size);
        }
        if self.is_local != false {
            my_size += 1 + 1;
        }
        if self.is_reliable != false {
            my_size += 1 + 1;
        }
        if self.is_bridge != false {
            my_size += 1 + 1;
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.num_slots != 0 {
            os.write_int32(2, self.num_slots)?;
        }
        if self.slot_size != 0 {
            os.write_int32(3, self.slot_size)?;
        }
        if self.is_local != false {
            os.write_bool(4, self.is_local)?;
        }
        if self.is_reliable != false {
            os.write_bool(5, self.is_reliable)?;
        }
        if self.is_bridge != false {
            os.write_bool(6, self.is_bridge)?;
        }
        if !self.type_.is_empty() {
            os.write_bytes(7, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatePublisherRequest {
        CreatePublisherRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.num_slots = 0;
        self.slot_size = 0;
        self.is_local = false;
        self.is_reliable = false;
        self.is_bridge = false;
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatePublisherRequest {
        static instance: CreatePublisherRequest = CreatePublisherRequest {
            channel_name: ::std::string::String::new(),
            num_slots: 0,
            slot_size: 0,
            is_local: false,
            is_reliable: false,
            is_bridge: false,
            type_: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreatePublisherRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreatePublisherRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreatePublisherRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePublisherRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.CreatePublisherResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreatePublisherResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.channel_id)
    pub channel_id: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.publisher_id)
    pub publisher_id: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.ccb_fd_index)
    pub ccb_fd_index: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.buffers)
    pub buffers: ::std::vec::Vec<BufferInfo>,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.pub_poll_fd_index)
    pub pub_poll_fd_index: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.pub_trigger_fd_index)
    pub pub_trigger_fd_index: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.sub_trigger_fd_indexes)
    pub sub_trigger_fd_indexes: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.num_sub_updates)
    pub num_sub_updates: i32,
    // @@protoc_insertion_point(field:subspace.CreatePublisherResponse.type)
    pub type_: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.CreatePublisherResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatePublisherResponse {
    fn default() -> &'a CreatePublisherResponse {
        <CreatePublisherResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreatePublisherResponse {
    pub fn new() -> CreatePublisherResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &CreatePublisherResponse| { &m.error },
            |m: &mut CreatePublisherResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &CreatePublisherResponse| { &m.channel_id },
            |m: &mut CreatePublisherResponse| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "publisher_id",
            |m: &CreatePublisherResponse| { &m.publisher_id },
            |m: &mut CreatePublisherResponse| { &mut m.publisher_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ccb_fd_index",
            |m: &CreatePublisherResponse| { &m.ccb_fd_index },
            |m: &mut CreatePublisherResponse| { &mut m.ccb_fd_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffers",
            |m: &CreatePublisherResponse| { &m.buffers },
            |m: &mut CreatePublisherResponse| { &mut m.buffers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pub_poll_fd_index",
            |m: &CreatePublisherResponse| { &m.pub_poll_fd_index },
            |m: &mut CreatePublisherResponse| { &mut m.pub_poll_fd_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pub_trigger_fd_index",
            |m: &CreatePublisherResponse| { &m.pub_trigger_fd_index },
            |m: &mut CreatePublisherResponse| { &mut m.pub_trigger_fd_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub_trigger_fd_indexes",
            |m: &CreatePublisherResponse| { &m.sub_trigger_fd_indexes },
            |m: &mut CreatePublisherResponse| { &mut m.sub_trigger_fd_indexes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_sub_updates",
            |m: &CreatePublisherResponse| { &m.num_sub_updates },
            |m: &mut CreatePublisherResponse| { &mut m.num_sub_updates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CreatePublisherResponse| { &m.type_ },
            |m: &mut CreatePublisherResponse| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreatePublisherResponse>(
            "CreatePublisherResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreatePublisherResponse {
    const NAME: &'static str = "CreatePublisherResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                16 => {
                    self.channel_id = is.read_int32()?;
                },
                24 => {
                    self.publisher_id = is.read_int32()?;
                },
                32 => {
                    self.ccb_fd_index = is.read_int32()?;
                },
                42 => {
                    self.buffers.push(is.read_message()?);
                },
                48 => {
                    self.pub_poll_fd_index = is.read_int32()?;
                },
                56 => {
                    self.pub_trigger_fd_index = is.read_int32()?;
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.sub_trigger_fd_indexes)?;
                },
                64 => {
                    self.sub_trigger_fd_indexes.push(is.read_int32()?);
                },
                72 => {
                    self.num_sub_updates = is.read_int32()?;
                },
                82 => {
                    self.type_ = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.channel_id);
        }
        if self.publisher_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.publisher_id);
        }
        if self.ccb_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.ccb_fd_index);
        }
        for value in &self.buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.pub_poll_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.pub_poll_fd_index);
        }
        if self.pub_trigger_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.pub_trigger_fd_index);
        }
        for value in &self.sub_trigger_fd_indexes {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        if self.num_sub_updates != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.num_sub_updates);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        if self.channel_id != 0 {
            os.write_int32(2, self.channel_id)?;
        }
        if self.publisher_id != 0 {
            os.write_int32(3, self.publisher_id)?;
        }
        if self.ccb_fd_index != 0 {
            os.write_int32(4, self.ccb_fd_index)?;
        }
        for v in &self.buffers {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.pub_poll_fd_index != 0 {
            os.write_int32(6, self.pub_poll_fd_index)?;
        }
        if self.pub_trigger_fd_index != 0 {
            os.write_int32(7, self.pub_trigger_fd_index)?;
        }
        for v in &self.sub_trigger_fd_indexes {
            os.write_int32(8, *v)?;
        };
        if self.num_sub_updates != 0 {
            os.write_int32(9, self.num_sub_updates)?;
        }
        if !self.type_.is_empty() {
            os.write_bytes(10, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatePublisherResponse {
        CreatePublisherResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.channel_id = 0;
        self.publisher_id = 0;
        self.ccb_fd_index = 0;
        self.buffers.clear();
        self.pub_poll_fd_index = 0;
        self.pub_trigger_fd_index = 0;
        self.sub_trigger_fd_indexes.clear();
        self.num_sub_updates = 0;
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatePublisherResponse {
        static instance: CreatePublisherResponse = CreatePublisherResponse {
            error: ::std::string::String::new(),
            channel_id: 0,
            publisher_id: 0,
            ccb_fd_index: 0,
            buffers: ::std::vec::Vec::new(),
            pub_poll_fd_index: 0,
            pub_trigger_fd_index: 0,
            sub_trigger_fd_indexes: ::std::vec::Vec::new(),
            num_sub_updates: 0,
            type_: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreatePublisherResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreatePublisherResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreatePublisherResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePublisherResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is used both to create a new subscriber and to reload
///  an existing one.  If channel_id is not -1, it refers to
///  an existing subscriber to the channel.
// @@protoc_insertion_point(message:subspace.CreateSubscriberRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateSubscriberRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.CreateSubscriberRequest.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberRequest.subscriber_id)
    pub subscriber_id: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberRequest.is_reliable)
    pub is_reliable: bool,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberRequest.is_bridge)
    pub is_bridge: bool,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberRequest.type)
    pub type_: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberRequest.max_shared_ptrs)
    pub max_shared_ptrs: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.CreateSubscriberRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSubscriberRequest {
    fn default() -> &'a CreateSubscriberRequest {
        <CreateSubscriberRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSubscriberRequest {
    pub fn new() -> CreateSubscriberRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &CreateSubscriberRequest| { &m.channel_name },
            |m: &mut CreateSubscriberRequest| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriber_id",
            |m: &CreateSubscriberRequest| { &m.subscriber_id },
            |m: &mut CreateSubscriberRequest| { &mut m.subscriber_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_reliable",
            |m: &CreateSubscriberRequest| { &m.is_reliable },
            |m: &mut CreateSubscriberRequest| { &mut m.is_reliable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bridge",
            |m: &CreateSubscriberRequest| { &m.is_bridge },
            |m: &mut CreateSubscriberRequest| { &mut m.is_bridge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CreateSubscriberRequest| { &m.type_ },
            |m: &mut CreateSubscriberRequest| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_shared_ptrs",
            |m: &CreateSubscriberRequest| { &m.max_shared_ptrs },
            |m: &mut CreateSubscriberRequest| { &mut m.max_shared_ptrs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSubscriberRequest>(
            "CreateSubscriberRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSubscriberRequest {
    const NAME: &'static str = "CreateSubscriberRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.subscriber_id = is.read_int32()?;
                },
                24 => {
                    self.is_reliable = is.read_bool()?;
                },
                32 => {
                    self.is_bridge = is.read_bool()?;
                },
                42 => {
                    self.type_ = is.read_bytes()?;
                },
                48 => {
                    self.max_shared_ptrs = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.subscriber_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.subscriber_id);
        }
        if self.is_reliable != false {
            my_size += 1 + 1;
        }
        if self.is_bridge != false {
            my_size += 1 + 1;
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.type_);
        }
        if self.max_shared_ptrs != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.max_shared_ptrs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.subscriber_id != 0 {
            os.write_int32(2, self.subscriber_id)?;
        }
        if self.is_reliable != false {
            os.write_bool(3, self.is_reliable)?;
        }
        if self.is_bridge != false {
            os.write_bool(4, self.is_bridge)?;
        }
        if !self.type_.is_empty() {
            os.write_bytes(5, &self.type_)?;
        }
        if self.max_shared_ptrs != 0 {
            os.write_int32(6, self.max_shared_ptrs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSubscriberRequest {
        CreateSubscriberRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.subscriber_id = 0;
        self.is_reliable = false;
        self.is_bridge = false;
        self.type_.clear();
        self.max_shared_ptrs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSubscriberRequest {
        static instance: CreateSubscriberRequest = CreateSubscriberRequest {
            channel_name: ::std::string::String::new(),
            subscriber_id: 0,
            is_reliable: false,
            is_bridge: false,
            type_: ::std::vec::Vec::new(),
            max_shared_ptrs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSubscriberRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSubscriberRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSubscriberRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSubscriberRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.CreateSubscriberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateSubscriberResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.channel_id)
    pub channel_id: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.subscriber_id)
    pub subscriber_id: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.ccb_fd_index)
    pub ccb_fd_index: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.buffers)
    pub buffers: ::std::vec::Vec<BufferInfo>,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.trigger_fd_index)
    pub trigger_fd_index: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.poll_fd_index)
    pub poll_fd_index: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.slot_size)
    pub slot_size: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.num_slots)
    pub num_slots: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.reliable_pub_trigger_fd_indexes)
    pub reliable_pub_trigger_fd_indexes: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.num_pub_updates)
    pub num_pub_updates: i32,
    // @@protoc_insertion_point(field:subspace.CreateSubscriberResponse.type)
    pub type_: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.CreateSubscriberResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSubscriberResponse {
    fn default() -> &'a CreateSubscriberResponse {
        <CreateSubscriberResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateSubscriberResponse {
    pub fn new() -> CreateSubscriberResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &CreateSubscriberResponse| { &m.error },
            |m: &mut CreateSubscriberResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &CreateSubscriberResponse| { &m.channel_id },
            |m: &mut CreateSubscriberResponse| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriber_id",
            |m: &CreateSubscriberResponse| { &m.subscriber_id },
            |m: &mut CreateSubscriberResponse| { &mut m.subscriber_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ccb_fd_index",
            |m: &CreateSubscriberResponse| { &m.ccb_fd_index },
            |m: &mut CreateSubscriberResponse| { &mut m.ccb_fd_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffers",
            |m: &CreateSubscriberResponse| { &m.buffers },
            |m: &mut CreateSubscriberResponse| { &mut m.buffers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trigger_fd_index",
            |m: &CreateSubscriberResponse| { &m.trigger_fd_index },
            |m: &mut CreateSubscriberResponse| { &mut m.trigger_fd_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "poll_fd_index",
            |m: &CreateSubscriberResponse| { &m.poll_fd_index },
            |m: &mut CreateSubscriberResponse| { &mut m.poll_fd_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &CreateSubscriberResponse| { &m.slot_size },
            |m: &mut CreateSubscriberResponse| { &mut m.slot_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_slots",
            |m: &CreateSubscriberResponse| { &m.num_slots },
            |m: &mut CreateSubscriberResponse| { &mut m.num_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reliable_pub_trigger_fd_indexes",
            |m: &CreateSubscriberResponse| { &m.reliable_pub_trigger_fd_indexes },
            |m: &mut CreateSubscriberResponse| { &mut m.reliable_pub_trigger_fd_indexes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_pub_updates",
            |m: &CreateSubscriberResponse| { &m.num_pub_updates },
            |m: &mut CreateSubscriberResponse| { &mut m.num_pub_updates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CreateSubscriberResponse| { &m.type_ },
            |m: &mut CreateSubscriberResponse| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSubscriberResponse>(
            "CreateSubscriberResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSubscriberResponse {
    const NAME: &'static str = "CreateSubscriberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                16 => {
                    self.channel_id = is.read_int32()?;
                },
                24 => {
                    self.subscriber_id = is.read_int32()?;
                },
                32 => {
                    self.ccb_fd_index = is.read_int32()?;
                },
                42 => {
                    self.buffers.push(is.read_message()?);
                },
                48 => {
                    self.trigger_fd_index = is.read_int32()?;
                },
                56 => {
                    self.poll_fd_index = is.read_int32()?;
                },
                64 => {
                    self.slot_size = is.read_int32()?;
                },
                72 => {
                    self.num_slots = is.read_int32()?;
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.reliable_pub_trigger_fd_indexes)?;
                },
                80 => {
                    self.reliable_pub_trigger_fd_indexes.push(is.read_int32()?);
                },
                88 => {
                    self.num_pub_updates = is.read_int32()?;
                },
                98 => {
                    self.type_ = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.channel_id);
        }
        if self.subscriber_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.subscriber_id);
        }
        if self.ccb_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.ccb_fd_index);
        }
        for value in &self.buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.trigger_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.trigger_fd_index);
        }
        if self.poll_fd_index != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.poll_fd_index);
        }
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.slot_size);
        }
        if self.num_slots != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.num_slots);
        }
        for value in &self.reliable_pub_trigger_fd_indexes {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        if self.num_pub_updates != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.num_pub_updates);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        if self.channel_id != 0 {
            os.write_int32(2, self.channel_id)?;
        }
        if self.subscriber_id != 0 {
            os.write_int32(3, self.subscriber_id)?;
        }
        if self.ccb_fd_index != 0 {
            os.write_int32(4, self.ccb_fd_index)?;
        }
        for v in &self.buffers {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.trigger_fd_index != 0 {
            os.write_int32(6, self.trigger_fd_index)?;
        }
        if self.poll_fd_index != 0 {
            os.write_int32(7, self.poll_fd_index)?;
        }
        if self.slot_size != 0 {
            os.write_int32(8, self.slot_size)?;
        }
        if self.num_slots != 0 {
            os.write_int32(9, self.num_slots)?;
        }
        for v in &self.reliable_pub_trigger_fd_indexes {
            os.write_int32(10, *v)?;
        };
        if self.num_pub_updates != 0 {
            os.write_int32(11, self.num_pub_updates)?;
        }
        if !self.type_.is_empty() {
            os.write_bytes(12, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSubscriberResponse {
        CreateSubscriberResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.channel_id = 0;
        self.subscriber_id = 0;
        self.ccb_fd_index = 0;
        self.buffers.clear();
        self.trigger_fd_index = 0;
        self.poll_fd_index = 0;
        self.slot_size = 0;
        self.num_slots = 0;
        self.reliable_pub_trigger_fd_indexes.clear();
        self.num_pub_updates = 0;
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSubscriberResponse {
        static instance: CreateSubscriberResponse = CreateSubscriberResponse {
            error: ::std::string::String::new(),
            channel_id: 0,
            subscriber_id: 0,
            ccb_fd_index: 0,
            buffers: ::std::vec::Vec::new(),
            trigger_fd_index: 0,
            poll_fd_index: 0,
            slot_size: 0,
            num_slots: 0,
            reliable_pub_trigger_fd_indexes: ::std::vec::Vec::new(),
            num_pub_updates: 0,
            type_: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSubscriberResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSubscriberResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSubscriberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSubscriberResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.GetTriggersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTriggersRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.GetTriggersRequest.channel_name)
    pub channel_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.GetTriggersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTriggersRequest {
    fn default() -> &'a GetTriggersRequest {
        <GetTriggersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTriggersRequest {
    pub fn new() -> GetTriggersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &GetTriggersRequest| { &m.channel_name },
            |m: &mut GetTriggersRequest| { &mut m.channel_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTriggersRequest>(
            "GetTriggersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTriggersRequest {
    const NAME: &'static str = "GetTriggersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTriggersRequest {
        GetTriggersRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTriggersRequest {
        static instance: GetTriggersRequest = GetTriggersRequest {
            channel_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTriggersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTriggersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTriggersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTriggersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.GetTriggersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTriggersResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.GetTriggersResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.GetTriggersResponse.reliable_pub_trigger_fd_indexes)
    pub reliable_pub_trigger_fd_indexes: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:subspace.GetTriggersResponse.sub_trigger_fd_indexes)
    pub sub_trigger_fd_indexes: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.GetTriggersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTriggersResponse {
    fn default() -> &'a GetTriggersResponse {
        <GetTriggersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTriggersResponse {
    pub fn new() -> GetTriggersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &GetTriggersResponse| { &m.error },
            |m: &mut GetTriggersResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reliable_pub_trigger_fd_indexes",
            |m: &GetTriggersResponse| { &m.reliable_pub_trigger_fd_indexes },
            |m: &mut GetTriggersResponse| { &mut m.reliable_pub_trigger_fd_indexes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub_trigger_fd_indexes",
            |m: &GetTriggersResponse| { &m.sub_trigger_fd_indexes },
            |m: &mut GetTriggersResponse| { &mut m.sub_trigger_fd_indexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTriggersResponse>(
            "GetTriggersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTriggersResponse {
    const NAME: &'static str = "GetTriggersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.reliable_pub_trigger_fd_indexes)?;
                },
                16 => {
                    self.reliable_pub_trigger_fd_indexes.push(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.sub_trigger_fd_indexes)?;
                },
                24 => {
                    self.sub_trigger_fd_indexes.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        for value in &self.reliable_pub_trigger_fd_indexes {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        for value in &self.sub_trigger_fd_indexes {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        for v in &self.reliable_pub_trigger_fd_indexes {
            os.write_int32(2, *v)?;
        };
        for v in &self.sub_trigger_fd_indexes {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTriggersResponse {
        GetTriggersResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.reliable_pub_trigger_fd_indexes.clear();
        self.sub_trigger_fd_indexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTriggersResponse {
        static instance: GetTriggersResponse = GetTriggersResponse {
            error: ::std::string::String::new(),
            reliable_pub_trigger_fd_indexes: ::std::vec::Vec::new(),
            sub_trigger_fd_indexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTriggersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTriggersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTriggersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTriggersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.RemovePublisherRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemovePublisherRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.RemovePublisherRequest.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.RemovePublisherRequest.publisher_id)
    pub publisher_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.RemovePublisherRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemovePublisherRequest {
    fn default() -> &'a RemovePublisherRequest {
        <RemovePublisherRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemovePublisherRequest {
    pub fn new() -> RemovePublisherRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &RemovePublisherRequest| { &m.channel_name },
            |m: &mut RemovePublisherRequest| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "publisher_id",
            |m: &RemovePublisherRequest| { &m.publisher_id },
            |m: &mut RemovePublisherRequest| { &mut m.publisher_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemovePublisherRequest>(
            "RemovePublisherRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemovePublisherRequest {
    const NAME: &'static str = "RemovePublisherRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.publisher_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.publisher_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.publisher_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.publisher_id != 0 {
            os.write_int32(2, self.publisher_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemovePublisherRequest {
        RemovePublisherRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.publisher_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemovePublisherRequest {
        static instance: RemovePublisherRequest = RemovePublisherRequest {
            channel_name: ::std::string::String::new(),
            publisher_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemovePublisherRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemovePublisherRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemovePublisherRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePublisherRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.RemovePublisherResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemovePublisherResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.RemovePublisherResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.RemovePublisherResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemovePublisherResponse {
    fn default() -> &'a RemovePublisherResponse {
        <RemovePublisherResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemovePublisherResponse {
    pub fn new() -> RemovePublisherResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &RemovePublisherResponse| { &m.error },
            |m: &mut RemovePublisherResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemovePublisherResponse>(
            "RemovePublisherResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemovePublisherResponse {
    const NAME: &'static str = "RemovePublisherResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemovePublisherResponse {
        RemovePublisherResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemovePublisherResponse {
        static instance: RemovePublisherResponse = RemovePublisherResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemovePublisherResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemovePublisherResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemovePublisherResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePublisherResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.RemoveSubscriberRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveSubscriberRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.RemoveSubscriberRequest.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.RemoveSubscriberRequest.subscriber_id)
    pub subscriber_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.RemoveSubscriberRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveSubscriberRequest {
    fn default() -> &'a RemoveSubscriberRequest {
        <RemoveSubscriberRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveSubscriberRequest {
    pub fn new() -> RemoveSubscriberRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &RemoveSubscriberRequest| { &m.channel_name },
            |m: &mut RemoveSubscriberRequest| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriber_id",
            |m: &RemoveSubscriberRequest| { &m.subscriber_id },
            |m: &mut RemoveSubscriberRequest| { &mut m.subscriber_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveSubscriberRequest>(
            "RemoveSubscriberRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveSubscriberRequest {
    const NAME: &'static str = "RemoveSubscriberRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.subscriber_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.subscriber_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.subscriber_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.subscriber_id != 0 {
            os.write_int32(2, self.subscriber_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveSubscriberRequest {
        RemoveSubscriberRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.subscriber_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveSubscriberRequest {
        static instance: RemoveSubscriberRequest = RemoveSubscriberRequest {
            channel_name: ::std::string::String::new(),
            subscriber_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveSubscriberRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveSubscriberRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveSubscriberRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveSubscriberRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.RemoveSubscriberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveSubscriberResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.RemoveSubscriberResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.RemoveSubscriberResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveSubscriberResponse {
    fn default() -> &'a RemoveSubscriberResponse {
        <RemoveSubscriberResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemoveSubscriberResponse {
    pub fn new() -> RemoveSubscriberResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &RemoveSubscriberResponse| { &m.error },
            |m: &mut RemoveSubscriberResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveSubscriberResponse>(
            "RemoveSubscriberResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveSubscriberResponse {
    const NAME: &'static str = "RemoveSubscriberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveSubscriberResponse {
        RemoveSubscriberResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveSubscriberResponse {
        static instance: RemoveSubscriberResponse = RemoveSubscriberResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveSubscriberResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveSubscriberResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveSubscriberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveSubscriberResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.ResizeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResizeRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.ResizeRequest.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.ResizeRequest.new_slot_size)
    pub new_slot_size: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.ResizeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResizeRequest {
    fn default() -> &'a ResizeRequest {
        <ResizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResizeRequest {
    pub fn new() -> ResizeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &ResizeRequest| { &m.channel_name },
            |m: &mut ResizeRequest| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_slot_size",
            |m: &ResizeRequest| { &m.new_slot_size },
            |m: &mut ResizeRequest| { &mut m.new_slot_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResizeRequest>(
            "ResizeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResizeRequest {
    const NAME: &'static str = "ResizeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.new_slot_size = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.new_slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.new_slot_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.new_slot_size != 0 {
            os.write_int32(2, self.new_slot_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResizeRequest {
        ResizeRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.new_slot_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResizeRequest {
        static instance: ResizeRequest = ResizeRequest {
            channel_name: ::std::string::String::new(),
            new_slot_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResizeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResizeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResizeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.ResizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResizeResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.ResizeResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.ResizeResponse.buffers)
    pub buffers: ::std::vec::Vec<BufferInfo>,
    // @@protoc_insertion_point(field:subspace.ResizeResponse.slot_size)
    pub slot_size: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.ResizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResizeResponse {
    fn default() -> &'a ResizeResponse {
        <ResizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ResizeResponse {
    pub fn new() -> ResizeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &ResizeResponse| { &m.error },
            |m: &mut ResizeResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffers",
            |m: &ResizeResponse| { &m.buffers },
            |m: &mut ResizeResponse| { &mut m.buffers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &ResizeResponse| { &m.slot_size },
            |m: &mut ResizeResponse| { &mut m.slot_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResizeResponse>(
            "ResizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResizeResponse {
    const NAME: &'static str = "ResizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                18 => {
                    self.buffers.push(is.read_message()?);
                },
                24 => {
                    self.slot_size = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        for value in &self.buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.slot_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        for v in &self.buffers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.slot_size != 0 {
            os.write_int32(3, self.slot_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResizeResponse {
        ResizeResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.buffers.clear();
        self.slot_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResizeResponse {
        static instance: ResizeResponse = ResizeResponse {
            error: ::std::string::String::new(),
            buffers: ::std::vec::Vec::new(),
            slot_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.GetBuffersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBuffersRequest {
    // message fields
    // @@protoc_insertion_point(field:subspace.GetBuffersRequest.channel_name)
    pub channel_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.GetBuffersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBuffersRequest {
    fn default() -> &'a GetBuffersRequest {
        <GetBuffersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBuffersRequest {
    pub fn new() -> GetBuffersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &GetBuffersRequest| { &m.channel_name },
            |m: &mut GetBuffersRequest| { &mut m.channel_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBuffersRequest>(
            "GetBuffersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBuffersRequest {
    const NAME: &'static str = "GetBuffersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBuffersRequest {
        GetBuffersRequest::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBuffersRequest {
        static instance: GetBuffersRequest = GetBuffersRequest {
            channel_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBuffersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBuffersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBuffersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBuffersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.GetBuffersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBuffersResponse {
    // message fields
    // @@protoc_insertion_point(field:subspace.GetBuffersResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.GetBuffersResponse.buffers)
    pub buffers: ::std::vec::Vec<BufferInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.GetBuffersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBuffersResponse {
    fn default() -> &'a GetBuffersResponse {
        <GetBuffersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBuffersResponse {
    pub fn new() -> GetBuffersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &GetBuffersResponse| { &m.error },
            |m: &mut GetBuffersResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffers",
            |m: &GetBuffersResponse| { &m.buffers },
            |m: &mut GetBuffersResponse| { &mut m.buffers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBuffersResponse>(
            "GetBuffersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBuffersResponse {
    const NAME: &'static str = "GetBuffersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                18 => {
                    self.buffers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        for value in &self.buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        for v in &self.buffers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBuffersResponse {
        GetBuffersResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.buffers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBuffersResponse {
        static instance: GetBuffersResponse = GetBuffersResponse {
            error: ::std::string::String::new(),
            buffers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBuffersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBuffersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBuffersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBuffersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request {
    // message oneof groups
    pub request: ::std::option::Option<request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // .subspace.InitRequest init = 1;

    pub fn init(&self) -> &InitRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::Init(ref v)) => v,
            _ => <InitRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_init(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_init(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Init(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_init(&mut self, v: InitRequest) {
        self.request = ::std::option::Option::Some(request::Request::Init(v))
    }

    // Mutable pointer to the field.
    pub fn mut_init(&mut self) -> &mut InitRequest {
        if let ::std::option::Option::Some(request::Request::Init(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Init(InitRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Init(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_init(&mut self) -> InitRequest {
        if self.has_init() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Init(v)) => v,
                _ => panic!(),
            }
        } else {
            InitRequest::new()
        }
    }

    // .subspace.CreatePublisherRequest create_publisher = 2;

    pub fn create_publisher(&self) -> &CreatePublisherRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::CreatePublisher(ref v)) => v,
            _ => <CreatePublisherRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_publisher(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_create_publisher(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::CreatePublisher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_publisher(&mut self, v: CreatePublisherRequest) {
        self.request = ::std::option::Option::Some(request::Request::CreatePublisher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_publisher(&mut self) -> &mut CreatePublisherRequest {
        if let ::std::option::Option::Some(request::Request::CreatePublisher(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::CreatePublisher(CreatePublisherRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::CreatePublisher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_publisher(&mut self) -> CreatePublisherRequest {
        if self.has_create_publisher() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::CreatePublisher(v)) => v,
                _ => panic!(),
            }
        } else {
            CreatePublisherRequest::new()
        }
    }

    // .subspace.CreateSubscriberRequest create_subscriber = 3;

    pub fn create_subscriber(&self) -> &CreateSubscriberRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::CreateSubscriber(ref v)) => v,
            _ => <CreateSubscriberRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_subscriber(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_create_subscriber(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::CreateSubscriber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_subscriber(&mut self, v: CreateSubscriberRequest) {
        self.request = ::std::option::Option::Some(request::Request::CreateSubscriber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_subscriber(&mut self) -> &mut CreateSubscriberRequest {
        if let ::std::option::Option::Some(request::Request::CreateSubscriber(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::CreateSubscriber(CreateSubscriberRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::CreateSubscriber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_subscriber(&mut self) -> CreateSubscriberRequest {
        if self.has_create_subscriber() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::CreateSubscriber(v)) => v,
                _ => panic!(),
            }
        } else {
            CreateSubscriberRequest::new()
        }
    }

    // .subspace.GetTriggersRequest get_triggers = 4;

    pub fn get_triggers(&self) -> &GetTriggersRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::GetTriggers(ref v)) => v,
            _ => <GetTriggersRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_triggers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_triggers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::GetTriggers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_triggers(&mut self, v: GetTriggersRequest) {
        self.request = ::std::option::Option::Some(request::Request::GetTriggers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_triggers(&mut self) -> &mut GetTriggersRequest {
        if let ::std::option::Option::Some(request::Request::GetTriggers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::GetTriggers(GetTriggersRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::GetTriggers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_triggers(&mut self) -> GetTriggersRequest {
        if self.has_get_triggers() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::GetTriggers(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTriggersRequest::new()
        }
    }

    // .subspace.RemovePublisherRequest remove_publisher = 5;

    pub fn remove_publisher(&self) -> &RemovePublisherRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::RemovePublisher(ref v)) => v,
            _ => <RemovePublisherRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_publisher(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_publisher(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::RemovePublisher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_publisher(&mut self, v: RemovePublisherRequest) {
        self.request = ::std::option::Option::Some(request::Request::RemovePublisher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_publisher(&mut self) -> &mut RemovePublisherRequest {
        if let ::std::option::Option::Some(request::Request::RemovePublisher(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::RemovePublisher(RemovePublisherRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::RemovePublisher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_publisher(&mut self) -> RemovePublisherRequest {
        if self.has_remove_publisher() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::RemovePublisher(v)) => v,
                _ => panic!(),
            }
        } else {
            RemovePublisherRequest::new()
        }
    }

    // .subspace.RemoveSubscriberRequest remove_subscriber = 6;

    pub fn remove_subscriber(&self) -> &RemoveSubscriberRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::RemoveSubscriber(ref v)) => v,
            _ => <RemoveSubscriberRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_subscriber(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_subscriber(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::RemoveSubscriber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_subscriber(&mut self, v: RemoveSubscriberRequest) {
        self.request = ::std::option::Option::Some(request::Request::RemoveSubscriber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_subscriber(&mut self) -> &mut RemoveSubscriberRequest {
        if let ::std::option::Option::Some(request::Request::RemoveSubscriber(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::RemoveSubscriber(RemoveSubscriberRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::RemoveSubscriber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_subscriber(&mut self) -> RemoveSubscriberRequest {
        if self.has_remove_subscriber() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::RemoveSubscriber(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveSubscriberRequest::new()
        }
    }

    // .subspace.ResizeRequest resize = 7;

    pub fn resize(&self) -> &ResizeRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::Resize(ref v)) => v,
            _ => <ResizeRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_resize(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_resize(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Resize(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resize(&mut self, v: ResizeRequest) {
        self.request = ::std::option::Option::Some(request::Request::Resize(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resize(&mut self) -> &mut ResizeRequest {
        if let ::std::option::Option::Some(request::Request::Resize(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Resize(ResizeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Resize(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resize(&mut self) -> ResizeRequest {
        if self.has_resize() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Resize(v)) => v,
                _ => panic!(),
            }
        } else {
            ResizeRequest::new()
        }
    }

    // .subspace.GetBuffersRequest get_buffers = 8;

    pub fn get_buffers(&self) -> &GetBuffersRequest {
        match self.request {
            ::std::option::Option::Some(request::Request::GetBuffers(ref v)) => v,
            _ => <GetBuffersRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_buffers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_buffers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::GetBuffers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_buffers(&mut self, v: GetBuffersRequest) {
        self.request = ::std::option::Option::Some(request::Request::GetBuffers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_buffers(&mut self) -> &mut GetBuffersRequest {
        if let ::std::option::Option::Some(request::Request::GetBuffers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::GetBuffers(GetBuffersRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::GetBuffers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_buffers(&mut self) -> GetBuffersRequest {
        if self.has_get_buffers() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::GetBuffers(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBuffersRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InitRequest>(
            "init",
            Request::has_init,
            Request::init,
            Request::mut_init,
            Request::set_init,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CreatePublisherRequest>(
            "create_publisher",
            Request::has_create_publisher,
            Request::create_publisher,
            Request::mut_create_publisher,
            Request::set_create_publisher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CreateSubscriberRequest>(
            "create_subscriber",
            Request::has_create_subscriber,
            Request::create_subscriber,
            Request::mut_create_subscriber,
            Request::set_create_subscriber,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetTriggersRequest>(
            "get_triggers",
            Request::has_get_triggers,
            Request::get_triggers,
            Request::mut_get_triggers,
            Request::set_get_triggers,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemovePublisherRequest>(
            "remove_publisher",
            Request::has_remove_publisher,
            Request::remove_publisher,
            Request::mut_remove_publisher,
            Request::set_remove_publisher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemoveSubscriberRequest>(
            "remove_subscriber",
            Request::has_remove_subscriber,
            Request::remove_subscriber,
            Request::mut_remove_subscriber,
            Request::set_remove_subscriber,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResizeRequest>(
            "resize",
            Request::has_resize,
            Request::resize,
            Request::mut_resize,
            Request::set_resize,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetBuffersRequest>(
            "get_buffers",
            Request::has_get_buffers,
            Request::get_buffers,
            Request::mut_get_buffers,
            Request::set_get_buffers,
        ));
        oneofs.push(request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Request>(
            "Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Request {
    const NAME: &'static str = "Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(request::Request::Init(is.read_message()?));
                },
                18 => {
                    self.request = ::std::option::Option::Some(request::Request::CreatePublisher(is.read_message()?));
                },
                26 => {
                    self.request = ::std::option::Option::Some(request::Request::CreateSubscriber(is.read_message()?));
                },
                34 => {
                    self.request = ::std::option::Option::Some(request::Request::GetTriggers(is.read_message()?));
                },
                42 => {
                    self.request = ::std::option::Option::Some(request::Request::RemovePublisher(is.read_message()?));
                },
                50 => {
                    self.request = ::std::option::Option::Some(request::Request::RemoveSubscriber(is.read_message()?));
                },
                58 => {
                    self.request = ::std::option::Option::Some(request::Request::Resize(is.read_message()?));
                },
                66 => {
                    self.request = ::std::option::Option::Some(request::Request::GetBuffers(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &request::Request::Init(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::CreatePublisher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::CreateSubscriber(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::GetTriggers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::RemovePublisher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::RemoveSubscriber(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Resize(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::GetBuffers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &request::Request::Init(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &request::Request::CreatePublisher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &request::Request::CreateSubscriber(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &request::Request::GetTriggers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &request::Request::RemovePublisher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &request::Request::RemoveSubscriber(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &request::Request::Resize(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &request::Request::GetBuffers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Request {
        Request::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Request {
        static instance: Request = Request {
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Request`
pub mod request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:subspace.Request.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:subspace.Request.init)
        Init(super::InitRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.create_publisher)
        CreatePublisher(super::CreatePublisherRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.create_subscriber)
        CreateSubscriber(super::CreateSubscriberRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.get_triggers)
        GetTriggers(super::GetTriggersRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.remove_publisher)
        RemovePublisher(super::RemovePublisherRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.remove_subscriber)
        RemoveSubscriber(super::RemoveSubscriberRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.resize)
        Resize(super::ResizeRequest),
        // @@protoc_insertion_point(oneof_field:subspace.Request.get_buffers)
        GetBuffers(super::GetBuffersRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Request as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

// @@protoc_insertion_point(message:subspace.Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response {
    // message oneof groups
    pub response: ::std::option::Option<response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .subspace.InitResponse init = 1;

    pub fn init(&self) -> &InitResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::Init(ref v)) => v,
            _ => <InitResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_init(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_init(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Init(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_init(&mut self, v: InitResponse) {
        self.response = ::std::option::Option::Some(response::Response::Init(v))
    }

    // Mutable pointer to the field.
    pub fn mut_init(&mut self) -> &mut InitResponse {
        if let ::std::option::Option::Some(response::Response::Init(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Init(InitResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Init(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_init(&mut self) -> InitResponse {
        if self.has_init() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Init(v)) => v,
                _ => panic!(),
            }
        } else {
            InitResponse::new()
        }
    }

    // .subspace.CreatePublisherResponse create_publisher = 2;

    pub fn create_publisher(&self) -> &CreatePublisherResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::CreatePublisher(ref v)) => v,
            _ => <CreatePublisherResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_publisher(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_create_publisher(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::CreatePublisher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_publisher(&mut self, v: CreatePublisherResponse) {
        self.response = ::std::option::Option::Some(response::Response::CreatePublisher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_publisher(&mut self) -> &mut CreatePublisherResponse {
        if let ::std::option::Option::Some(response::Response::CreatePublisher(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::CreatePublisher(CreatePublisherResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::CreatePublisher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_publisher(&mut self) -> CreatePublisherResponse {
        if self.has_create_publisher() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::CreatePublisher(v)) => v,
                _ => panic!(),
            }
        } else {
            CreatePublisherResponse::new()
        }
    }

    // .subspace.CreateSubscriberResponse create_subscriber = 3;

    pub fn create_subscriber(&self) -> &CreateSubscriberResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::CreateSubscriber(ref v)) => v,
            _ => <CreateSubscriberResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_subscriber(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_create_subscriber(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::CreateSubscriber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_subscriber(&mut self, v: CreateSubscriberResponse) {
        self.response = ::std::option::Option::Some(response::Response::CreateSubscriber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_subscriber(&mut self) -> &mut CreateSubscriberResponse {
        if let ::std::option::Option::Some(response::Response::CreateSubscriber(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::CreateSubscriber(CreateSubscriberResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::CreateSubscriber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_subscriber(&mut self) -> CreateSubscriberResponse {
        if self.has_create_subscriber() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::CreateSubscriber(v)) => v,
                _ => panic!(),
            }
        } else {
            CreateSubscriberResponse::new()
        }
    }

    // .subspace.GetTriggersResponse get_triggers = 4;

    pub fn get_triggers(&self) -> &GetTriggersResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::GetTriggers(ref v)) => v,
            _ => <GetTriggersResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_triggers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_triggers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::GetTriggers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_triggers(&mut self, v: GetTriggersResponse) {
        self.response = ::std::option::Option::Some(response::Response::GetTriggers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_triggers(&mut self) -> &mut GetTriggersResponse {
        if let ::std::option::Option::Some(response::Response::GetTriggers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::GetTriggers(GetTriggersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::GetTriggers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_triggers(&mut self) -> GetTriggersResponse {
        if self.has_get_triggers() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::GetTriggers(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTriggersResponse::new()
        }
    }

    // .subspace.RemovePublisherResponse remove_publisher = 5;

    pub fn remove_publisher(&self) -> &RemovePublisherResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::RemovePublisher(ref v)) => v,
            _ => <RemovePublisherResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_publisher(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_publisher(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::RemovePublisher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_publisher(&mut self, v: RemovePublisherResponse) {
        self.response = ::std::option::Option::Some(response::Response::RemovePublisher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_publisher(&mut self) -> &mut RemovePublisherResponse {
        if let ::std::option::Option::Some(response::Response::RemovePublisher(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::RemovePublisher(RemovePublisherResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::RemovePublisher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_publisher(&mut self) -> RemovePublisherResponse {
        if self.has_remove_publisher() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::RemovePublisher(v)) => v,
                _ => panic!(),
            }
        } else {
            RemovePublisherResponse::new()
        }
    }

    // .subspace.RemoveSubscriberResponse remove_subscriber = 6;

    pub fn remove_subscriber(&self) -> &RemoveSubscriberResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::RemoveSubscriber(ref v)) => v,
            _ => <RemoveSubscriberResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_subscriber(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_subscriber(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::RemoveSubscriber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_subscriber(&mut self, v: RemoveSubscriberResponse) {
        self.response = ::std::option::Option::Some(response::Response::RemoveSubscriber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_subscriber(&mut self) -> &mut RemoveSubscriberResponse {
        if let ::std::option::Option::Some(response::Response::RemoveSubscriber(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::RemoveSubscriber(RemoveSubscriberResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::RemoveSubscriber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_subscriber(&mut self) -> RemoveSubscriberResponse {
        if self.has_remove_subscriber() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::RemoveSubscriber(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveSubscriberResponse::new()
        }
    }

    // .subspace.ResizeResponse resize = 7;

    pub fn resize(&self) -> &ResizeResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::Resize(ref v)) => v,
            _ => <ResizeResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_resize(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_resize(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Resize(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resize(&mut self, v: ResizeResponse) {
        self.response = ::std::option::Option::Some(response::Response::Resize(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resize(&mut self) -> &mut ResizeResponse {
        if let ::std::option::Option::Some(response::Response::Resize(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Resize(ResizeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Resize(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resize(&mut self) -> ResizeResponse {
        if self.has_resize() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Resize(v)) => v,
                _ => panic!(),
            }
        } else {
            ResizeResponse::new()
        }
    }

    // .subspace.GetBuffersResponse get_buffers = 8;

    pub fn get_buffers(&self) -> &GetBuffersResponse {
        match self.response {
            ::std::option::Option::Some(response::Response::GetBuffers(ref v)) => v,
            _ => <GetBuffersResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_buffers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_buffers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::GetBuffers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_buffers(&mut self, v: GetBuffersResponse) {
        self.response = ::std::option::Option::Some(response::Response::GetBuffers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_buffers(&mut self) -> &mut GetBuffersResponse {
        if let ::std::option::Option::Some(response::Response::GetBuffers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::GetBuffers(GetBuffersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::GetBuffers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_buffers(&mut self) -> GetBuffersResponse {
        if self.has_get_buffers() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::GetBuffers(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBuffersResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InitResponse>(
            "init",
            Response::has_init,
            Response::init,
            Response::mut_init,
            Response::set_init,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CreatePublisherResponse>(
            "create_publisher",
            Response::has_create_publisher,
            Response::create_publisher,
            Response::mut_create_publisher,
            Response::set_create_publisher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CreateSubscriberResponse>(
            "create_subscriber",
            Response::has_create_subscriber,
            Response::create_subscriber,
            Response::mut_create_subscriber,
            Response::set_create_subscriber,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetTriggersResponse>(
            "get_triggers",
            Response::has_get_triggers,
            Response::get_triggers,
            Response::mut_get_triggers,
            Response::set_get_triggers,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemovePublisherResponse>(
            "remove_publisher",
            Response::has_remove_publisher,
            Response::remove_publisher,
            Response::mut_remove_publisher,
            Response::set_remove_publisher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemoveSubscriberResponse>(
            "remove_subscriber",
            Response::has_remove_subscriber,
            Response::remove_subscriber,
            Response::mut_remove_subscriber,
            Response::set_remove_subscriber,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResizeResponse>(
            "resize",
            Response::has_resize,
            Response::resize,
            Response::mut_resize,
            Response::set_resize,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetBuffersResponse>(
            "get_buffers",
            Response::has_get_buffers,
            Response::get_buffers,
            Response::mut_get_buffers,
            Response::set_get_buffers,
        ));
        oneofs.push(response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Response>(
            "Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Response {
    const NAME: &'static str = "Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(response::Response::Init(is.read_message()?));
                },
                18 => {
                    self.response = ::std::option::Option::Some(response::Response::CreatePublisher(is.read_message()?));
                },
                26 => {
                    self.response = ::std::option::Option::Some(response::Response::CreateSubscriber(is.read_message()?));
                },
                34 => {
                    self.response = ::std::option::Option::Some(response::Response::GetTriggers(is.read_message()?));
                },
                42 => {
                    self.response = ::std::option::Option::Some(response::Response::RemovePublisher(is.read_message()?));
                },
                50 => {
                    self.response = ::std::option::Option::Some(response::Response::RemoveSubscriber(is.read_message()?));
                },
                58 => {
                    self.response = ::std::option::Option::Some(response::Response::Resize(is.read_message()?));
                },
                66 => {
                    self.response = ::std::option::Option::Some(response::Response::GetBuffers(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &response::Response::Init(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::CreatePublisher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::CreateSubscriber(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::GetTriggers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::RemovePublisher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::RemoveSubscriber(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Resize(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::GetBuffers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &response::Response::Init(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &response::Response::CreatePublisher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &response::Response::CreateSubscriber(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &response::Response::GetTriggers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &response::Response::RemovePublisher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &response::Response::RemoveSubscriber(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &response::Response::Resize(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &response::Response::GetBuffers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Response {
        Response::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Response {
        static instance: Response = Response {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Response`
pub mod response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:subspace.Response.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:subspace.Response.init)
        Init(super::InitResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.create_publisher)
        CreatePublisher(super::CreatePublisherResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.create_subscriber)
        CreateSubscriber(super::CreateSubscriberResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.get_triggers)
        GetTriggers(super::GetTriggersResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.remove_publisher)
        RemovePublisher(super::RemovePublisherResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.remove_subscriber)
        RemoveSubscriber(super::RemoveSubscriberResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.resize)
        Resize(super::ResizeResponse),
        // @@protoc_insertion_point(oneof_field:subspace.Response.get_buffers)
        GetBuffers(super::GetBuffersResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Response as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

///  These messages are carried on Subspace channels published by
///  the server.
// @@protoc_insertion_point(message:subspace.ChannelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelInfo {
    // message fields
    // @@protoc_insertion_point(field:subspace.ChannelInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.ChannelInfo.slot_size)
    pub slot_size: i32,
    // @@protoc_insertion_point(field:subspace.ChannelInfo.num_slots)
    pub num_slots: i32,
    // @@protoc_insertion_point(field:subspace.ChannelInfo.type)
    pub type_: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.ChannelInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelInfo {
    fn default() -> &'a ChannelInfo {
        <ChannelInfo as ::protobuf::Message>::default_instance()
    }
}

impl ChannelInfo {
    pub fn new() -> ChannelInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ChannelInfo| { &m.name },
            |m: &mut ChannelInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &ChannelInfo| { &m.slot_size },
            |m: &mut ChannelInfo| { &mut m.slot_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_slots",
            |m: &ChannelInfo| { &m.num_slots },
            |m: &mut ChannelInfo| { &mut m.num_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ChannelInfo| { &m.type_ },
            |m: &mut ChannelInfo| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelInfo>(
            "ChannelInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelInfo {
    const NAME: &'static str = "ChannelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.slot_size = is.read_int32()?;
                },
                24 => {
                    self.num_slots = is.read_int32()?;
                },
                34 => {
                    self.type_ = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.slot_size);
        }
        if self.num_slots != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.num_slots);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.slot_size != 0 {
            os.write_int32(2, self.slot_size)?;
        }
        if self.num_slots != 0 {
            os.write_int32(3, self.num_slots)?;
        }
        if !self.type_.is_empty() {
            os.write_bytes(4, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelInfo {
        ChannelInfo::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.slot_size = 0;
        self.num_slots = 0;
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelInfo {
        static instance: ChannelInfo = ChannelInfo {
            name: ::std::string::String::new(),
            slot_size: 0,
            num_slots: 0,
            type_: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is published to the /subspace/ChannelDirectory channel.
// @@protoc_insertion_point(message:subspace.ChannelDirectory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelDirectory {
    // message fields
    // @@protoc_insertion_point(field:subspace.ChannelDirectory.server_id)
    pub server_id: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.ChannelDirectory.channels)
    pub channels: ::std::vec::Vec<ChannelInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.ChannelDirectory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelDirectory {
    fn default() -> &'a ChannelDirectory {
        <ChannelDirectory as ::protobuf::Message>::default_instance()
    }
}

impl ChannelDirectory {
    pub fn new() -> ChannelDirectory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_id",
            |m: &ChannelDirectory| { &m.server_id },
            |m: &mut ChannelDirectory| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &ChannelDirectory| { &m.channels },
            |m: &mut ChannelDirectory| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelDirectory>(
            "ChannelDirectory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelDirectory {
    const NAME: &'static str = "ChannelDirectory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_id = is.read_string()?;
                },
                18 => {
                    self.channels.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.server_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.server_id);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.server_id.is_empty() {
            os.write_string(1, &self.server_id)?;
        }
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelDirectory {
        ChannelDirectory::new()
    }

    fn clear(&mut self) {
        self.server_id.clear();
        self.channels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelDirectory {
        static instance: ChannelDirectory = ChannelDirectory {
            server_id: ::std::string::String::new(),
            channels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelDirectory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelDirectory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelDirectory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelDirectory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.ChannelStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelStats {
    // message fields
    // @@protoc_insertion_point(field:subspace.ChannelStats.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.ChannelStats.total_bytes)
    pub total_bytes: i64,
    // @@protoc_insertion_point(field:subspace.ChannelStats.total_messages)
    pub total_messages: i64,
    // @@protoc_insertion_point(field:subspace.ChannelStats.slot_size)
    pub slot_size: i32,
    // @@protoc_insertion_point(field:subspace.ChannelStats.num_slots)
    pub num_slots: i32,
    // @@protoc_insertion_point(field:subspace.ChannelStats.num_pubs)
    pub num_pubs: i32,
    // @@protoc_insertion_point(field:subspace.ChannelStats.num_subs)
    pub num_subs: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.ChannelStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelStats {
    fn default() -> &'a ChannelStats {
        <ChannelStats as ::protobuf::Message>::default_instance()
    }
}

impl ChannelStats {
    pub fn new() -> ChannelStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &ChannelStats| { &m.channel_name },
            |m: &mut ChannelStats| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_bytes",
            |m: &ChannelStats| { &m.total_bytes },
            |m: &mut ChannelStats| { &mut m.total_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_messages",
            |m: &ChannelStats| { &m.total_messages },
            |m: &mut ChannelStats| { &mut m.total_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &ChannelStats| { &m.slot_size },
            |m: &mut ChannelStats| { &mut m.slot_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_slots",
            |m: &ChannelStats| { &m.num_slots },
            |m: &mut ChannelStats| { &mut m.num_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_pubs",
            |m: &ChannelStats| { &m.num_pubs },
            |m: &mut ChannelStats| { &mut m.num_pubs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_subs",
            |m: &ChannelStats| { &m.num_subs },
            |m: &mut ChannelStats| { &mut m.num_subs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelStats>(
            "ChannelStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelStats {
    const NAME: &'static str = "ChannelStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.total_bytes = is.read_int64()?;
                },
                24 => {
                    self.total_messages = is.read_int64()?;
                },
                32 => {
                    self.slot_size = is.read_int32()?;
                },
                40 => {
                    self.num_slots = is.read_int32()?;
                },
                48 => {
                    self.num_pubs = is.read_int32()?;
                },
                56 => {
                    self.num_subs = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.total_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.total_bytes);
        }
        if self.total_messages != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.total_messages);
        }
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.slot_size);
        }
        if self.num_slots != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.num_slots);
        }
        if self.num_pubs != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.num_pubs);
        }
        if self.num_subs != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.num_subs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.total_bytes != 0 {
            os.write_int64(2, self.total_bytes)?;
        }
        if self.total_messages != 0 {
            os.write_int64(3, self.total_messages)?;
        }
        if self.slot_size != 0 {
            os.write_int32(4, self.slot_size)?;
        }
        if self.num_slots != 0 {
            os.write_int32(5, self.num_slots)?;
        }
        if self.num_pubs != 0 {
            os.write_int32(6, self.num_pubs)?;
        }
        if self.num_subs != 0 {
            os.write_int32(7, self.num_subs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelStats {
        ChannelStats::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.total_bytes = 0;
        self.total_messages = 0;
        self.slot_size = 0;
        self.num_slots = 0;
        self.num_pubs = 0;
        self.num_subs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelStats {
        static instance: ChannelStats = ChannelStats {
            channel_name: ::std::string::String::new(),
            total_bytes: 0,
            total_messages: 0,
            slot_size: 0,
            num_slots: 0,
            num_pubs: 0,
            num_subs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is published to the /subspace/Statistics channel.
// @@protoc_insertion_point(message:subspace.Statistics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Statistics {
    // message fields
    // @@protoc_insertion_point(field:subspace.Statistics.server_id)
    pub server_id: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.Statistics.timestamp)
    pub timestamp: i64,
    // @@protoc_insertion_point(field:subspace.Statistics.channels)
    pub channels: ::std::vec::Vec<ChannelStats>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.Statistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Statistics {
    fn default() -> &'a Statistics {
        <Statistics as ::protobuf::Message>::default_instance()
    }
}

impl Statistics {
    pub fn new() -> Statistics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_id",
            |m: &Statistics| { &m.server_id },
            |m: &mut Statistics| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Statistics| { &m.timestamp },
            |m: &mut Statistics| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &Statistics| { &m.channels },
            |m: &mut Statistics| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Statistics>(
            "Statistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Statistics {
    const NAME: &'static str = "Statistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_id = is.read_string()?;
                },
                16 => {
                    self.timestamp = is.read_int64()?;
                },
                26 => {
                    self.channels.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.server_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.server_id);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.timestamp);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.server_id.is_empty() {
            os.write_string(1, &self.server_id)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Statistics {
        Statistics::new()
    }

    fn clear(&mut self) {
        self.server_id.clear();
        self.timestamp = 0;
        self.channels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Statistics {
        static instance: Statistics = Statistics {
            server_id: ::std::string::String::new(),
            timestamp: 0,
            channels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Statistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Statistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Statistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:subspace.ChannelAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelAddress {
    // message fields
    // @@protoc_insertion_point(field:subspace.ChannelAddress.ip_address)
    pub ip_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:subspace.ChannelAddress.port)
    pub port: i32,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.ChannelAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelAddress {
    fn default() -> &'a ChannelAddress {
        <ChannelAddress as ::protobuf::Message>::default_instance()
    }
}

impl ChannelAddress {
    pub fn new() -> ChannelAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ip_address",
            |m: &ChannelAddress| { &m.ip_address },
            |m: &mut ChannelAddress| { &mut m.ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &ChannelAddress| { &m.port },
            |m: &mut ChannelAddress| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelAddress>(
            "ChannelAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelAddress {
    const NAME: &'static str = "ChannelAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip_address = is.read_bytes()?;
                },
                16 => {
                    self.port = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ip_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ip_address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ip_address.is_empty() {
            os.write_bytes(1, &self.ip_address)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelAddress {
        ChannelAddress::new()
    }

    fn clear(&mut self) {
        self.ip_address.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelAddress {
        static instance: ChannelAddress = ChannelAddress {
            ip_address: ::std::vec::Vec::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is sent over the connected channel TCP bridge when the
///  bridged subscription is successful.
// @@protoc_insertion_point(message:subspace.Subscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subscribed {
    // message fields
    // @@protoc_insertion_point(field:subspace.Subscribed.channel_name)
    pub channel_name: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.Subscribed.slot_size)
    pub slot_size: i32,
    // @@protoc_insertion_point(field:subspace.Subscribed.num_slots)
    pub num_slots: i32,
    // @@protoc_insertion_point(field:subspace.Subscribed.reliable)
    pub reliable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.Subscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Subscribed {
    fn default() -> &'a Subscribed {
        <Subscribed as ::protobuf::Message>::default_instance()
    }
}

impl Subscribed {
    pub fn new() -> Subscribed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_name",
            |m: &Subscribed| { &m.channel_name },
            |m: &mut Subscribed| { &mut m.channel_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_size",
            |m: &Subscribed| { &m.slot_size },
            |m: &mut Subscribed| { &mut m.slot_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_slots",
            |m: &Subscribed| { &m.num_slots },
            |m: &mut Subscribed| { &mut m.num_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reliable",
            |m: &Subscribed| { &m.reliable },
            |m: &mut Subscribed| { &mut m.reliable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscribed>(
            "Subscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Subscribed {
    const NAME: &'static str = "Subscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_name = is.read_string()?;
                },
                16 => {
                    self.slot_size = is.read_int32()?;
                },
                24 => {
                    self.num_slots = is.read_int32()?;
                },
                32 => {
                    self.reliable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_name);
        }
        if self.slot_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.slot_size);
        }
        if self.num_slots != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.num_slots);
        }
        if self.reliable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_name.is_empty() {
            os.write_string(1, &self.channel_name)?;
        }
        if self.slot_size != 0 {
            os.write_int32(2, self.slot_size)?;
        }
        if self.num_slots != 0 {
            os.write_int32(3, self.num_slots)?;
        }
        if self.reliable != false {
            os.write_bool(4, self.reliable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Subscribed {
        Subscribed::new()
    }

    fn clear(&mut self) {
        self.channel_name.clear();
        self.slot_size = 0;
        self.num_slots = 0;
        self.reliable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Subscribed {
        static instance: Subscribed = Subscribed {
            channel_name: ::std::string::String::new(),
            slot_size: 0,
            num_slots: 0,
            reliable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Subscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Subscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Subscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This message is sent over UDP.
// @@protoc_insertion_point(message:subspace.Discovery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Discovery {
    // message fields
    // @@protoc_insertion_point(field:subspace.Discovery.server_id)
    pub server_id: ::std::string::String,
    // @@protoc_insertion_point(field:subspace.Discovery.port)
    pub port: i32,
    // message oneof groups
    pub data: ::std::option::Option<discovery::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:subspace.Discovery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Discovery {
    fn default() -> &'a Discovery {
        <Discovery as ::protobuf::Message>::default_instance()
    }
}

impl Discovery {
    pub fn new() -> Discovery {
        ::std::default::Default::default()
    }

    // .subspace.Discovery.Query query = 3;

    pub fn query(&self) -> &discovery::Query {
        match self.data {
            ::std::option::Option::Some(discovery::Data::Query(ref v)) => v,
            _ => <discovery::Query as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_query(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(discovery::Data::Query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: discovery::Query) {
        self.data = ::std::option::Option::Some(discovery::Data::Query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut discovery::Query {
        if let ::std::option::Option::Some(discovery::Data::Query(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(discovery::Data::Query(discovery::Query::new()));
        }
        match self.data {
            ::std::option::Option::Some(discovery::Data::Query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> discovery::Query {
        if self.has_query() {
            match self.data.take() {
                ::std::option::Option::Some(discovery::Data::Query(v)) => v,
                _ => panic!(),
            }
        } else {
            discovery::Query::new()
        }
    }

    // .subspace.Discovery.Advertise advertise = 4;

    pub fn advertise(&self) -> &discovery::Advertise {
        match self.data {
            ::std::option::Option::Some(discovery::Data::Advertise(ref v)) => v,
            _ => <discovery::Advertise as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_advertise(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_advertise(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(discovery::Data::Advertise(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_advertise(&mut self, v: discovery::Advertise) {
        self.data = ::std::option::Option::Some(discovery::Data::Advertise(v))
    }

    // Mutable pointer to the field.
    pub fn mut_advertise(&mut self) -> &mut discovery::Advertise {
        if let ::std::option::Option::Some(discovery::Data::Advertise(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(discovery::Data::Advertise(discovery::Advertise::new()));
        }
        match self.data {
            ::std::option::Option::Some(discovery::Data::Advertise(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_advertise(&mut self) -> discovery::Advertise {
        if self.has_advertise() {
            match self.data.take() {
                ::std::option::Option::Some(discovery::Data::Advertise(v)) => v,
                _ => panic!(),
            }
        } else {
            discovery::Advertise::new()
        }
    }

    // .subspace.Discovery.Subscribe subscribe = 5;

    pub fn subscribe(&self) -> &discovery::Subscribe {
        match self.data {
            ::std::option::Option::Some(discovery::Data::Subscribe(ref v)) => v,
            _ => <discovery::Subscribe as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_subscribe(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_subscribe(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(discovery::Data::Subscribe(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_subscribe(&mut self, v: discovery::Subscribe) {
        self.data = ::std::option::Option::Some(discovery::Data::Subscribe(v))
    }

    // Mutable pointer to the field.
    pub fn mut_subscribe(&mut self) -> &mut discovery::Subscribe {
        if let ::std::option::Option::Some(discovery::Data::Subscribe(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(discovery::Data::Subscribe(discovery::Subscribe::new()));
        }
        match self.data {
            ::std::option::Option::Some(discovery::Data::Subscribe(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_subscribe(&mut self) -> discovery::Subscribe {
        if self.has_subscribe() {
            match self.data.take() {
                ::std::option::Option::Some(discovery::Data::Subscribe(v)) => v,
                _ => panic!(),
            }
        } else {
            discovery::Subscribe::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_id",
            |m: &Discovery| { &m.server_id },
            |m: &mut Discovery| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &Discovery| { &m.port },
            |m: &mut Discovery| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, discovery::Query>(
            "query",
            Discovery::has_query,
            Discovery::query,
            Discovery::mut_query,
            Discovery::set_query,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, discovery::Advertise>(
            "advertise",
            Discovery::has_advertise,
            Discovery::advertise,
            Discovery::mut_advertise,
            Discovery::set_advertise,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, discovery::Subscribe>(
            "subscribe",
            Discovery::has_subscribe,
            Discovery::subscribe,
            Discovery::mut_subscribe,
            Discovery::set_subscribe,
        ));
        oneofs.push(discovery::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Discovery>(
            "Discovery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Discovery {
    const NAME: &'static str = "Discovery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_id = is.read_string()?;
                },
                16 => {
                    self.port = is.read_int32()?;
                },
                26 => {
                    self.data = ::std::option::Option::Some(discovery::Data::Query(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(discovery::Data::Advertise(is.read_message()?));
                },
                42 => {
                    self.data = ::std::option::Option::Some(discovery::Data::Subscribe(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.server_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.server_id);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.port);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &discovery::Data::Query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &discovery::Data::Advertise(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &discovery::Data::Subscribe(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.server_id.is_empty() {
            os.write_string(1, &self.server_id)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &discovery::Data::Query(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &discovery::Data::Advertise(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &discovery::Data::Subscribe(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Discovery {
        Discovery::new()
    }

    fn clear(&mut self) {
        self.server_id.clear();
        self.port = 0;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Discovery {
        static instance: Discovery = Discovery {
            server_id: ::std::string::String::new(),
            port: 0,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Discovery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Discovery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Discovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Discovery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Discovery`
pub mod discovery {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:subspace.Discovery.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:subspace.Discovery.query)
        Query(Query),
        // @@protoc_insertion_point(oneof_field:subspace.Discovery.advertise)
        Advertise(Advertise),
        // @@protoc_insertion_point(oneof_field:subspace.Discovery.subscribe)
        Subscribe(Subscribe),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Discovery as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
    ///  Ask which server is publishing the named channel.
    // @@protoc_insertion_point(message:subspace.Discovery.Query)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Query {
        // message fields
        // @@protoc_insertion_point(field:subspace.Discovery.Query.channel_name)
        pub channel_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:subspace.Discovery.Query.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Query {
        fn default() -> &'a Query {
            <Query as ::protobuf::Message>::default_instance()
        }
    }

    impl Query {
        pub fn new() -> Query {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel_name",
                |m: &Query| { &m.channel_name },
                |m: &mut Query| { &mut m.channel_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Query>(
                "Discovery.Query",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Query {
        const NAME: &'static str = "Query";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.channel_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.channel_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.channel_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.channel_name.is_empty() {
                os.write_string(1, &self.channel_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Query {
            Query::new()
        }

        fn clear(&mut self) {
            self.channel_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Query {
            static instance: Query = Query {
                channel_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Query {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Discovery.Query").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Query {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Query {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Advertise that the sender is publishing a channel.
    // @@protoc_insertion_point(message:subspace.Discovery.Advertise)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Advertise {
        // message fields
        // @@protoc_insertion_point(field:subspace.Discovery.Advertise.channel_name)
        pub channel_name: ::std::string::String,
        // @@protoc_insertion_point(field:subspace.Discovery.Advertise.reliable)
        pub reliable: bool,
        // special fields
        // @@protoc_insertion_point(special_field:subspace.Discovery.Advertise.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Advertise {
        fn default() -> &'a Advertise {
            <Advertise as ::protobuf::Message>::default_instance()
        }
    }

    impl Advertise {
        pub fn new() -> Advertise {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel_name",
                |m: &Advertise| { &m.channel_name },
                |m: &mut Advertise| { &mut m.channel_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "reliable",
                |m: &Advertise| { &m.reliable },
                |m: &mut Advertise| { &mut m.reliable },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Advertise>(
                "Discovery.Advertise",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Advertise {
        const NAME: &'static str = "Advertise";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.channel_name = is.read_string()?;
                    },
                    16 => {
                        self.reliable = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.channel_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.channel_name);
            }
            if self.reliable != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.channel_name.is_empty() {
                os.write_string(1, &self.channel_name)?;
            }
            if self.reliable != false {
                os.write_bool(2, self.reliable)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Advertise {
            Advertise::new()
        }

        fn clear(&mut self) {
            self.channel_name.clear();
            self.reliable = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Advertise {
            static instance: Advertise = Advertise {
                channel_name: ::std::string::String::new(),
                reliable: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Advertise {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Discovery.Advertise").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Advertise {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Advertise {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Subscribe to the given channel.  The sender is listening
    ///  on the address specified in 'receiver'.
    // @@protoc_insertion_point(message:subspace.Discovery.Subscribe)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Subscribe {
        // message fields
        // @@protoc_insertion_point(field:subspace.Discovery.Subscribe.channel_name)
        pub channel_name: ::std::string::String,
        // @@protoc_insertion_point(field:subspace.Discovery.Subscribe.receiver)
        pub receiver: ::protobuf::MessageField<super::ChannelAddress>,
        // @@protoc_insertion_point(field:subspace.Discovery.Subscribe.reliable)
        pub reliable: bool,
        // special fields
        // @@protoc_insertion_point(special_field:subspace.Discovery.Subscribe.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Subscribe {
        fn default() -> &'a Subscribe {
            <Subscribe as ::protobuf::Message>::default_instance()
        }
    }

    impl Subscribe {
        pub fn new() -> Subscribe {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel_name",
                |m: &Subscribe| { &m.channel_name },
                |m: &mut Subscribe| { &mut m.channel_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ChannelAddress>(
                "receiver",
                |m: &Subscribe| { &m.receiver },
                |m: &mut Subscribe| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "reliable",
                |m: &Subscribe| { &m.reliable },
                |m: &mut Subscribe| { &mut m.reliable },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscribe>(
                "Discovery.Subscribe",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Subscribe {
        const NAME: &'static str = "Subscribe";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.channel_name = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.receiver)?;
                    },
                    24 => {
                        self.reliable = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.channel_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.channel_name);
            }
            if let Some(v) = self.receiver.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.reliable != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.channel_name.is_empty() {
                os.write_string(1, &self.channel_name)?;
            }
            if let Some(v) = self.receiver.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.reliable != false {
                os.write_bool(3, self.reliable)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Subscribe {
            Subscribe::new()
        }

        fn clear(&mut self) {
            self.channel_name.clear();
            self.receiver.clear();
            self.reliable = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Subscribe {
            static instance: Subscribe = Subscribe {
                channel_name: ::std::string::String::new(),
                receiver: ::protobuf::MessageField::none(),
                reliable: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Subscribe {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Discovery.Subscribe").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Subscribe {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Subscribe {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19src/protos/subspace.proto\x12\x08subspace\".\n\x0bInitRequest\x12\
    \x1f\n\x0bclient_name\x18\x01\x20\x01(\tR\nclientName\"0\n\x0cInitRespon\
    se\x12\x20\n\x0cscb_fd_index\x18\x01\x20\x01(\x05R\nscbFdIndex\"D\n\nBuf\
    ferInfo\x12\x1b\n\tslot_size\x18\x01\x20\x01(\x05R\x08slotSize\x12\x19\n\
    \x08fd_index\x18\x02\x20\x01(\x05R\x07fdIndex\"\xe2\x01\n\x16CreatePubli\
    sherRequest\x12!\n\x0cchannel_name\x18\x01\x20\x01(\tR\x0bchannelName\
    \x12\x1b\n\tnum_slots\x18\x02\x20\x01(\x05R\x08numSlots\x12\x1b\n\tslot_\
    size\x18\x03\x20\x01(\x05R\x08slotSize\x12\x19\n\x08is_local\x18\x04\x20\
    \x01(\x08R\x07isLocal\x12\x1f\n\x0bis_reliable\x18\x05\x20\x01(\x08R\nis\
    Reliable\x12\x1b\n\tis_bridge\x18\x06\x20\x01(\x08R\x08isBridge\x12\x12\
    \n\x04type\x18\x07\x20\x01(\x0cR\x04type\"\x90\x03\n\x17CreatePublisherR\
    esponse\x12\x14\n\x05error\x18\x01\x20\x01(\tR\x05error\x12\x1d\n\nchann\
    el_id\x18\x02\x20\x01(\x05R\tchannelId\x12!\n\x0cpublisher_id\x18\x03\
    \x20\x01(\x05R\x0bpublisherId\x12\x20\n\x0cccb_fd_index\x18\x04\x20\x01(\
    \x05R\nccbFdIndex\x12.\n\x07buffers\x18\x05\x20\x03(\x0b2\x14.subspace.B\
    ufferInfoR\x07buffers\x12)\n\x11pub_poll_fd_index\x18\x06\x20\x01(\x05R\
    \x0epubPollFdIndex\x12/\n\x14pub_trigger_fd_index\x18\x07\x20\x01(\x05R\
    \x11pubTriggerFdIndex\x123\n\x16sub_trigger_fd_indexes\x18\x08\x20\x03(\
    \x05R\x13subTriggerFdIndexes\x12&\n\x0fnum_sub_updates\x18\t\x20\x01(\
    \x05R\rnumSubUpdates\x12\x12\n\x04type\x18\n\x20\x01(\x0cR\x04type\"\xdb\
    \x01\n\x17CreateSubscriberRequest\x12!\n\x0cchannel_name\x18\x01\x20\x01\
    (\tR\x0bchannelName\x12#\n\rsubscriber_id\x18\x02\x20\x01(\x05R\x0csubsc\
    riberId\x12\x1f\n\x0bis_reliable\x18\x03\x20\x01(\x08R\nisReliable\x12\
    \x1b\n\tis_bridge\x18\x04\x20\x01(\x08R\x08isBridge\x12\x12\n\x04type\
    \x18\x05\x20\x01(\x0cR\x04type\x12&\n\x0fmax_shared_ptrs\x18\x06\x20\x01\
    (\x05R\rmaxSharedPtrs\"\xd0\x03\n\x18CreateSubscriberResponse\x12\x14\n\
    \x05error\x18\x01\x20\x01(\tR\x05error\x12\x1d\n\nchannel_id\x18\x02\x20\
    \x01(\x05R\tchannelId\x12#\n\rsubscriber_id\x18\x03\x20\x01(\x05R\x0csub\
    scriberId\x12\x20\n\x0cccb_fd_index\x18\x04\x20\x01(\x05R\nccbFdIndex\
    \x12.\n\x07buffers\x18\x05\x20\x03(\x0b2\x14.subspace.BufferInfoR\x07buf\
    fers\x12(\n\x10trigger_fd_index\x18\x06\x20\x01(\x05R\x0etriggerFdIndex\
    \x12\"\n\rpoll_fd_index\x18\x07\x20\x01(\x05R\x0bpollFdIndex\x12\x1b\n\t\
    slot_size\x18\x08\x20\x01(\x05R\x08slotSize\x12\x1b\n\tnum_slots\x18\t\
    \x20\x01(\x05R\x08numSlots\x12D\n\x1freliable_pub_trigger_fd_indexes\x18\
    \n\x20\x03(\x05R\x1breliablePubTriggerFdIndexes\x12&\n\x0fnum_pub_update\
    s\x18\x0b\x20\x01(\x05R\rnumPubUpdates\x12\x12\n\x04type\x18\x0c\x20\x01\
    (\x0cR\x04type\"7\n\x12GetTriggersRequest\x12!\n\x0cchannel_name\x18\x01\
    \x20\x01(\tR\x0bchannelName\"\xa6\x01\n\x13GetTriggersResponse\x12\x14\n\
    \x05error\x18\x01\x20\x01(\tR\x05error\x12D\n\x1freliable_pub_trigger_fd\
    _indexes\x18\x02\x20\x03(\x05R\x1breliablePubTriggerFdIndexes\x123\n\x16\
    sub_trigger_fd_indexes\x18\x03\x20\x03(\x05R\x13subTriggerFdIndexes\"^\n\
    \x16RemovePublisherRequest\x12!\n\x0cchannel_name\x18\x01\x20\x01(\tR\
    \x0bchannelName\x12!\n\x0cpublisher_id\x18\x02\x20\x01(\x05R\x0bpublishe\
    rId\"/\n\x17RemovePublisherResponse\x12\x14\n\x05error\x18\x01\x20\x01(\
    \tR\x05error\"a\n\x17RemoveSubscriberRequest\x12!\n\x0cchannel_name\x18\
    \x01\x20\x01(\tR\x0bchannelName\x12#\n\rsubscriber_id\x18\x02\x20\x01(\
    \x05R\x0csubscriberId\"0\n\x18RemoveSubscriberResponse\x12\x14\n\x05erro\
    r\x18\x01\x20\x01(\tR\x05error\"V\n\rResizeRequest\x12!\n\x0cchannel_nam\
    e\x18\x01\x20\x01(\tR\x0bchannelName\x12\"\n\rnew_slot_size\x18\x02\x20\
    \x01(\x05R\x0bnewSlotSize\"s\n\x0eResizeResponse\x12\x14\n\x05error\x18\
    \x01\x20\x01(\tR\x05error\x12.\n\x07buffers\x18\x02\x20\x03(\x0b2\x14.su\
    bspace.BufferInfoR\x07buffers\x12\x1b\n\tslot_size\x18\x03\x20\x01(\x05R\
    \x08slotSize\"6\n\x11GetBuffersRequest\x12!\n\x0cchannel_name\x18\x01\
    \x20\x01(\tR\x0bchannelName\"Z\n\x12GetBuffersResponse\x12\x14\n\x05erro\
    r\x18\x01\x20\x01(\tR\x05error\x12.\n\x07buffers\x18\x02\x20\x03(\x0b2\
    \x14.subspace.BufferInfoR\x07buffers\"\xb9\x04\n\x07Request\x12+\n\x04in\
    it\x18\x01\x20\x01(\x0b2\x15.subspace.InitRequestH\0R\x04init\x12M\n\x10\
    create_publisher\x18\x02\x20\x01(\x0b2\x20.subspace.CreatePublisherReque\
    stH\0R\x0fcreatePublisher\x12P\n\x11create_subscriber\x18\x03\x20\x01(\
    \x0b2!.subspace.CreateSubscriberRequestH\0R\x10createSubscriber\x12A\n\
    \x0cget_triggers\x18\x04\x20\x01(\x0b2\x1c.subspace.GetTriggersRequestH\
    \0R\x0bgetTriggers\x12M\n\x10remove_publisher\x18\x05\x20\x01(\x0b2\x20.\
    subspace.RemovePublisherRequestH\0R\x0fremovePublisher\x12P\n\x11remove_\
    subscriber\x18\x06\x20\x01(\x0b2!.subspace.RemoveSubscriberRequestH\0R\
    \x10removeSubscriber\x121\n\x06resize\x18\x07\x20\x01(\x0b2\x17.subspace\
    .ResizeRequestH\0R\x06resize\x12>\n\x0bget_buffers\x18\x08\x20\x01(\x0b2\
    \x1b.subspace.GetBuffersRequestH\0R\ngetBuffersB\t\n\x07request\"\xc3\
    \x04\n\x08Response\x12,\n\x04init\x18\x01\x20\x01(\x0b2\x16.subspace.Ini\
    tResponseH\0R\x04init\x12N\n\x10create_publisher\x18\x02\x20\x01(\x0b2!.\
    subspace.CreatePublisherResponseH\0R\x0fcreatePublisher\x12Q\n\x11create\
    _subscriber\x18\x03\x20\x01(\x0b2\".subspace.CreateSubscriberResponseH\0\
    R\x10createSubscriber\x12B\n\x0cget_triggers\x18\x04\x20\x01(\x0b2\x1d.s\
    ubspace.GetTriggersResponseH\0R\x0bgetTriggers\x12N\n\x10remove_publishe\
    r\x18\x05\x20\x01(\x0b2!.subspace.RemovePublisherResponseH\0R\x0fremoveP\
    ublisher\x12Q\n\x11remove_subscriber\x18\x06\x20\x01(\x0b2\".subspace.Re\
    moveSubscriberResponseH\0R\x10removeSubscriber\x122\n\x06resize\x18\x07\
    \x20\x01(\x0b2\x18.subspace.ResizeResponseH\0R\x06resize\x12?\n\x0bget_b\
    uffers\x18\x08\x20\x01(\x0b2\x1c.subspace.GetBuffersResponseH\0R\ngetBuf\
    fersB\n\n\x08response\"o\n\x0bChannelInfo\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1b\n\tslot_size\x18\x02\x20\x01(\x05R\x08slotSize\
    \x12\x1b\n\tnum_slots\x18\x03\x20\x01(\x05R\x08numSlots\x12\x12\n\x04typ\
    e\x18\x04\x20\x01(\x0cR\x04type\"b\n\x10ChannelDirectory\x12\x1b\n\tserv\
    er_id\x18\x01\x20\x01(\tR\x08serverId\x121\n\x08channels\x18\x02\x20\x03\
    (\x0b2\x15.subspace.ChannelInfoR\x08channels\"\xe9\x01\n\x0cChannelStats\
    \x12!\n\x0cchannel_name\x18\x01\x20\x01(\tR\x0bchannelName\x12\x1f\n\x0b\
    total_bytes\x18\x02\x20\x01(\x03R\ntotalBytes\x12%\n\x0etotal_messages\
    \x18\x03\x20\x01(\x03R\rtotalMessages\x12\x1b\n\tslot_size\x18\x04\x20\
    \x01(\x05R\x08slotSize\x12\x1b\n\tnum_slots\x18\x05\x20\x01(\x05R\x08num\
    Slots\x12\x19\n\x08num_pubs\x18\x06\x20\x01(\x05R\x07numPubs\x12\x19\n\
    \x08num_subs\x18\x07\x20\x01(\x05R\x07numSubs\"{\n\nStatistics\x12\x1b\n\
    \tserver_id\x18\x01\x20\x01(\tR\x08serverId\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x03R\ttimestamp\x122\n\x08channels\x18\x03\x20\x03(\x0b2\x16.s\
    ubspace.ChannelStatsR\x08channels\"C\n\x0eChannelAddress\x12\x1d\n\nip_a\
    ddress\x18\x01\x20\x01(\x0cR\tipAddress\x12\x12\n\x04port\x18\x02\x20\
    \x01(\x05R\x04port\"\x85\x01\n\nSubscribed\x12!\n\x0cchannel_name\x18\
    \x01\x20\x01(\tR\x0bchannelName\x12\x1b\n\tslot_size\x18\x02\x20\x01(\
    \x05R\x08slotSize\x12\x1b\n\tnum_slots\x18\x03\x20\x01(\x05R\x08numSlots\
    \x12\x1a\n\x08reliable\x18\x04\x20\x01(\x08R\x08reliable\"\xf0\x03\n\tDi\
    scovery\x12\x1b\n\tserver_id\x18\x01\x20\x01(\tR\x08serverId\x12\x12\n\
    \x04port\x18\x02\x20\x01(\x05R\x04port\x121\n\x05query\x18\x03\x20\x01(\
    \x0b2\x19.subspace.Discovery.QueryH\0R\x05query\x12=\n\tadvertise\x18\
    \x04\x20\x01(\x0b2\x1d.subspace.Discovery.AdvertiseH\0R\tadvertise\x12=\
    \n\tsubscribe\x18\x05\x20\x01(\x0b2\x1d.subspace.Discovery.SubscribeH\0R\
    \tsubscribe\x1a*\n\x05Query\x12!\n\x0cchannel_name\x18\x01\x20\x01(\tR\
    \x0bchannelName\x1aJ\n\tAdvertise\x12!\n\x0cchannel_name\x18\x01\x20\x01\
    (\tR\x0bchannelName\x12\x1a\n\x08reliable\x18\x02\x20\x01(\x08R\x08relia\
    ble\x1a\x80\x01\n\tSubscribe\x12!\n\x0cchannel_name\x18\x01\x20\x01(\tR\
    \x0bchannelName\x124\n\x08receiver\x18\x02\x20\x01(\x0b2\x18.subspace.Ch\
    annelAddressR\x08receiver\x12\x1a\n\x08reliable\x18\x03\x20\x01(\x08R\
    \x08reliableB\x06\n\x04dataJ\xb4C\n\x07\x12\x05\x04\0\xd8\x01\x01\nj\n\
    \x01\x0c\x12\x03\x04\0\x122`\x20Copyright\x202023\x20David\x20Allison\n\
    \x20All\x20Rights\x20Reserved\n\x20See\x20LICENSE\x20file\x20for\x20lice\
    nsing\x20information.\n\n\x08\n\x01\x02\x12\x03\x06\0\x11\n\t\n\x02\x04\
    \0\x12\x03\x08\0/\n\n\n\x03\x04\0\x01\x12\x03\x08\x08\x13\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x08\x16-\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x08\
    \x16\x1c\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x08\x1d(\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\x08+,\n\xd2\x02\n\x02\x04\x01\x12\x04\x10\0\x12\x01\
    \x1a\xc5\x02\x20All\x20Request\x20and\x20Response\x20messages\x20are\x20\
    carried\x20over\x20a\x20Unix\x20Domain\n\x20Socket\x20between\x20the\x20\
    client\x20and\x20the\x20server.\x20\x20They\x20are\x20followed\n\x20by\
    \x20an\x20array\x20of\x20file\x20descriptors\x20(SCM_RIGHTS\x20message)\
    \x20that\n\x20are\x20duped\x20from\x20the\x20server.\x20\x20These\x20fds\
    \x20are\x20for\x20shared\x20memory\n\x20segments\x20and\x20trigger\x20fd\
    s.\x20\x20The\x20messages\x20contain\x20indices\x20into\n\x20the\x20fd\
    \x20array.\n\n\n\n\x03\x04\x01\x01\x12\x03\x10\x08\x14\n7\n\x04\x04\x01\
    \x02\0\x12\x03\x11\x02\x19\"*\x20Index\x20into\x20fds\x20of\x20SystemCon\
    trolBlock\x20fd.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x11\x02\x07\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x11\x08\x14\n\x0c\n\x05\x04\x01\x02\
    \0\x03\x12\x03\x11\x17\x18\n\n\n\x02\x04\x02\x12\x04\x14\0\x17\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03\x14\x08\x12\n\x0b\n\x04\x04\x02\x02\0\x12\x03\
    \x15\x02\x16\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x15\x02\x07\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03\x15\x08\x11\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03\x15\x14\x15\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x16\x02\x15\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x16\x02\x07\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x16\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x16\x13\x14\n\n\n\x02\x04\x03\x12\x04\x19\0!\x01\n\n\n\x03\x04\x03\x01\
    \x12\x03\x19\x08\x1e\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1a\x02\x1a\n\x0c\
    \n\x05\x04\x03\x02\0\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03\x1a\t\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x1a\x18\x19\
    \n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x1b\x02\x16\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03\x1b\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x1b\
    \x08\x11\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1b\x14\x15\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03\x1c\x02\x16\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x03\x1c\x02\x07\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03\x1c\x08\x11\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03\x1c\x14\x15\n\x0b\n\x04\x04\x03\
    \x02\x03\x12\x03\x1d\x02\x14\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03\x1d\
    \x02\x06\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03\x1d\x07\x0f\n\x0c\n\x05\
    \x04\x03\x02\x03\x03\x12\x03\x1d\x12\x13\n\x0b\n\x04\x04\x03\x02\x04\x12\
    \x03\x1e\x02\x17\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03\x1e\x02\x06\n\
    \x0c\n\x05\x04\x03\x02\x04\x01\x12\x03\x1e\x07\x12\n\x0c\n\x05\x04\x03\
    \x02\x04\x03\x12\x03\x1e\x15\x16\n0\n\x04\x04\x03\x02\x05\x12\x03\x1f\
    \x02\x15\"#\x20This\x20publisher\x20is\x20for\x20the\x20bridge.\n\n\x0c\
    \n\x05\x04\x03\x02\x05\x05\x12\x03\x1f\x02\x06\n\x0c\n\x05\x04\x03\x02\
    \x05\x01\x12\x03\x1f\x07\x10\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03\x1f\
    \x13\x14\n/\n\x04\x04\x03\x02\x06\x12\x03\x20\x02\x11\"\"\x20Type\x20of\
    \x20data\x20carried\x20on\x20channel.\n\n\x0c\n\x05\x04\x03\x02\x06\x05\
    \x12\x03\x20\x02\x07\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03\x20\x08\x0c\
    \n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03\x20\x0f\x10\n\n\n\x02\x04\x04\
    \x12\x04#\0.\x01\n\n\n\x03\x04\x04\x01\x12\x03#\x08\x1f\n\x0b\n\x04\x04\
    \x04\x02\0\x12\x03$\x02\x13\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03$\x02\
    \x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03$\t\x0e\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x03$\x11\x12\n\x0b\n\x04\x04\x04\x02\x01\x12\x03%\x02\x17\
    \n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03%\x02\x07\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x03%\x08\x12\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03%\
    \x15\x16\n\x0b\n\x04\x04\x04\x02\x02\x12\x03&\x02\x19\n\x0c\n\x05\x04\
    \x04\x02\x02\x05\x12\x03&\x02\x07\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\
    \x03&\x08\x14\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03&\x17\x18\n\x0b\n\
    \x04\x04\x04\x02\x03\x12\x03'\x02\x19\n\x0c\n\x05\x04\x04\x02\x03\x05\
    \x12\x03'\x02\x07\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03'\x08\x14\n\x0c\
    \n\x05\x04\x04\x02\x03\x03\x12\x03'\x17\x18\n\x0b\n\x04\x04\x04\x02\x04\
    \x12\x03(\x02\"\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03(\x02\n\n\x0c\n\
    \x05\x04\x04\x02\x04\x06\x12\x03(\x0b\x15\n\x0c\n\x05\x04\x04\x02\x04\
    \x01\x12\x03(\x16\x1d\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03(\x20!\n\
    \x0b\n\x04\x04\x04\x02\x05\x12\x03)\x02\x1e\n\x0c\n\x05\x04\x04\x02\x05\
    \x05\x12\x03)\x02\x07\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03)\x08\x19\n\
    \x0c\n\x05\x04\x04\x02\x05\x03\x12\x03)\x1c\x1d\n\x0b\n\x04\x04\x04\x02\
    \x06\x12\x03*\x02!\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03*\x02\x07\n\
    \x0c\n\x05\x04\x04\x02\x06\x01\x12\x03*\x08\x1c\n\x0c\n\x05\x04\x04\x02\
    \x06\x03\x12\x03*\x1f\x20\n\x0b\n\x04\x04\x04\x02\x07\x12\x03+\x02,\n\
    \x0c\n\x05\x04\x04\x02\x07\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x07\x05\x12\x03+\x0b\x10\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03+\x11'\
    \n\x0c\n\x05\x04\x04\x02\x07\x03\x12\x03+*+\n\x0b\n\x04\x04\x04\x02\x08\
    \x12\x03,\x02\x1c\n\x0c\n\x05\x04\x04\x02\x08\x05\x12\x03,\x02\x07\n\x0c\
    \n\x05\x04\x04\x02\x08\x01\x12\x03,\x08\x17\n\x0c\n\x05\x04\x04\x02\x08\
    \x03\x12\x03,\x1a\x1b\n\x0b\n\x04\x04\x04\x02\t\x12\x03-\x02\x12\n\x0c\n\
    \x05\x04\x04\x02\t\x05\x12\x03-\x02\x07\n\x0c\n\x05\x04\x04\x02\t\x01\
    \x12\x03-\x08\x0c\n\x0c\n\x05\x04\x04\x02\t\x03\x12\x03-\x0f\x11\n\xaa\
    \x01\n\x02\x04\x05\x12\x043\0:\x01\x1a\x9d\x01\x20This\x20is\x20used\x20\
    both\x20to\x20create\x20a\x20new\x20subscriber\x20and\x20to\x20reload\n\
    \x20an\x20existing\x20one.\x20\x20If\x20channel_id\x20is\x20not\x20-1,\
    \x20it\x20refers\x20to\n\x20an\x20existing\x20subscriber\x20to\x20the\
    \x20channel.\n\n\n\n\x03\x04\x05\x01\x12\x033\x08\x1f\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x034\x02\x1a\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x034\x02\
    \x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x034\t\x15\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x034\x18\x19\n5\n\x04\x04\x05\x02\x01\x12\x035\x02\x1a\"(\
    \x20-1\x20if\x20there\x20is\x20no\x20existing\x20subscriber.\n\n\x0c\n\
    \x05\x04\x05\x02\x01\x05\x12\x035\x02\x07\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x035\x08\x15\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x035\x18\x19\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x036\x02\x17\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x036\x02\x06\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x036\x07\x12\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x036\x15\x16\n1\n\x04\x04\x05\x02\x03\
    \x12\x037\x02\x15\"$\x20This\x20subscriber\x20is\x20for\x20the\x20bridge\
    .\n\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x037\x02\x06\n\x0c\n\x05\x04\x05\
    \x02\x03\x01\x12\x037\x07\x10\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x037\
    \x13\x14\n/\n\x04\x04\x05\x02\x04\x12\x038\x02\x11\"\"\x20Type\x20of\x20\
    data\x20carried\x20on\x20channel.\n\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\
    \x038\x02\x07\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x038\x08\x0c\n\x0c\n\
    \x05\x04\x05\x02\x04\x03\x12\x038\x0f\x10\n0\n\x04\x04\x05\x02\x05\x12\
    \x039\x02\x1c\"#\x20Max\x20number\x20of\x20shared_ptr\x20objects.\n\n\
    \x0c\n\x05\x04\x05\x02\x05\x05\x12\x039\x02\x07\n\x0c\n\x05\x04\x05\x02\
    \x05\x01\x12\x039\x08\x17\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x039\x1a\
    \x1b\n\n\n\x02\x04\x06\x12\x04<\0I\x01\n\n\n\x03\x04\x06\x01\x12\x03<\
    \x08\x20\n\x0b\n\x04\x04\x06\x02\0\x12\x03=\x02\x13\n\x0c\n\x05\x04\x06\
    \x02\0\x05\x12\x03=\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03=\t\x0e\
    \n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03=\x11\x12\n\x0b\n\x04\x04\x06\x02\
    \x01\x12\x03>\x02\x17\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03>\x02\x07\n\
    \x0c\n\x05\x04\x06\x02\x01\x01\x12\x03>\x08\x12\n\x0c\n\x05\x04\x06\x02\
    \x01\x03\x12\x03>\x15\x16\n\x0b\n\x04\x04\x06\x02\x02\x12\x03?\x02\x1a\n\
    \x0c\n\x05\x04\x06\x02\x02\x05\x12\x03?\x02\x07\n\x0c\n\x05\x04\x06\x02\
    \x02\x01\x12\x03?\x08\x15\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03?\x18\
    \x19\n\x0b\n\x04\x04\x06\x02\x03\x12\x03@\x02\x19\n\x0c\n\x05\x04\x06\
    \x02\x03\x05\x12\x03@\x02\x07\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03@\
    \x08\x14\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03@\x17\x18\n\x0b\n\x04\
    \x04\x06\x02\x04\x12\x03A\x02\"\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03A\
    \x02\n\n\x0c\n\x05\x04\x06\x02\x04\x06\x12\x03A\x0b\x15\n\x0c\n\x05\x04\
    \x06\x02\x04\x01\x12\x03A\x16\x1d\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\
    \x03A\x20!\n\x0b\n\x04\x04\x06\x02\x05\x12\x03B\x02\x1d\n\x0c\n\x05\x04\
    \x06\x02\x05\x05\x12\x03B\x02\x07\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\
    \x03B\x08\x18\n\x0c\n\x05\x04\x06\x02\x05\x03\x12\x03B\x1b\x1c\n\x0b\n\
    \x04\x04\x06\x02\x06\x12\x03C\x02\x1a\n\x0c\n\x05\x04\x06\x02\x06\x05\
    \x12\x03C\x02\x07\n\x0c\n\x05\x04\x06\x02\x06\x01\x12\x03C\x08\x15\n\x0c\
    \n\x05\x04\x06\x02\x06\x03\x12\x03C\x18\x19\n-\n\x04\x04\x06\x02\x07\x12\
    \x03D\x02\x16\"\x20\x20Might\x20be\x20zero\x20if\x20no\x20publisher.\n\n\
    \x0c\n\x05\x04\x06\x02\x07\x05\x12\x03D\x02\x07\n\x0c\n\x05\x04\x06\x02\
    \x07\x01\x12\x03D\x08\x11\n\x0c\n\x05\x04\x06\x02\x07\x03\x12\x03D\x14\
    \x15\n-\n\x04\x04\x06\x02\x08\x12\x03E\x02\x16\"\x20\x20Might\x20be\x20z\
    ero\x20if\x20no\x20publisher.\n\n\x0c\n\x05\x04\x06\x02\x08\x05\x12\x03E\
    \x02\x07\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03E\x08\x11\n\x0c\n\x05\
    \x04\x06\x02\x08\x03\x12\x03E\x14\x15\n\x0b\n\x04\x04\x06\x02\t\x12\x03F\
    \x026\n\x0c\n\x05\x04\x06\x02\t\x04\x12\x03F\x02\n\n\x0c\n\x05\x04\x06\
    \x02\t\x05\x12\x03F\x0b\x10\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03F\x110\
    \n\x0c\n\x05\x04\x06\x02\t\x03\x12\x03F35\n\x0b\n\x04\x04\x06\x02\n\x12\
    \x03G\x02\x1d\n\x0c\n\x05\x04\x06\x02\n\x05\x12\x03G\x02\x07\n\x0c\n\x05\
    \x04\x06\x02\n\x01\x12\x03G\x08\x17\n\x0c\n\x05\x04\x06\x02\n\x03\x12\
    \x03G\x1a\x1c\n\x0b\n\x04\x04\x06\x02\x0b\x12\x03H\x02\x12\n\x0c\n\x05\
    \x04\x06\x02\x0b\x05\x12\x03H\x02\x07\n\x0c\n\x05\x04\x06\x02\x0b\x01\
    \x12\x03H\x08\x0c\n\x0c\n\x05\x04\x06\x02\x0b\x03\x12\x03H\x0f\x11\n\t\n\
    \x02\x04\x07\x12\x03K\07\n\n\n\x03\x04\x07\x01\x12\x03K\x08\x1a\n\x0b\n\
    \x04\x04\x07\x02\0\x12\x03K\x1d5\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03K\
    \x1d#\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03K$0\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03K34\n\n\n\x02\x04\x08\x12\x04M\0Q\x01\n\n\n\x03\x04\x08\x01\
    \x12\x03M\x08\x1b\n\x0b\n\x04\x04\x08\x02\0\x12\x03N\x02\x13\n\x0c\n\x05\
    \x04\x08\x02\0\x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03N\t\x0e\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03N\x11\x12\n\x0b\n\x04\
    \x04\x08\x02\x01\x12\x03O\x025\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03O\
    \x02\n\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03O\x0b\x10\n\x0c\n\x05\x04\
    \x08\x02\x01\x01\x12\x03O\x110\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03O3\
    4\n\x0b\n\x04\x04\x08\x02\x02\x12\x03P\x02,\n\x0c\n\x05\x04\x08\x02\x02\
    \x04\x12\x03P\x02\n\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03P\x0b\x10\n\
    \x0c\n\x05\x04\x08\x02\x02\x01\x12\x03P\x11'\n\x0c\n\x05\x04\x08\x02\x02\
    \x03\x12\x03P*+\n\n\n\x02\x04\t\x12\x04S\0V\x01\n\n\n\x03\x04\t\x01\x12\
    \x03S\x08\x1e\n\x0b\n\x04\x04\t\x02\0\x12\x03T\x02\x1a\n\x0c\n\x05\x04\t\
    \x02\0\x05\x12\x03T\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03T\t\x15\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03T\x18\x19\n\x0b\n\x04\x04\t\x02\x01\
    \x12\x03U\x02\x19\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03U\x02\x07\n\x0c\n\
    \x05\x04\t\x02\x01\x01\x12\x03U\x08\x14\n\x0c\n\x05\x04\t\x02\x01\x03\
    \x12\x03U\x17\x18\n\t\n\x02\x04\n\x12\x03X\05\n\n\n\x03\x04\n\x01\x12\
    \x03X\x08\x1f\n\x0b\n\x04\x04\n\x02\0\x12\x03X\"3\n\x0c\n\x05\x04\n\x02\
    \0\x05\x12\x03X\"(\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03X).\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03X12\n\n\n\x02\x04\x0b\x12\x04Z\0]\x01\n\n\n\x03\
    \x04\x0b\x01\x12\x03Z\x08\x1f\n\x0b\n\x04\x04\x0b\x02\0\x12\x03[\x02\x1a\
    \n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x0b\x02\
    \0\x01\x12\x03[\t\x15\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03[\x18\x19\n\
    \x0b\n\x04\x04\x0b\x02\x01\x12\x03\\\x02\x1a\n\x0c\n\x05\x04\x0b\x02\x01\
    \x05\x12\x03\\\x02\x07\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03\\\x08\x15\
    \n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03\\\x18\x19\n\t\n\x02\x04\x0c\x12\
    \x03_\06\n\n\n\x03\x04\x0c\x01\x12\x03_\x08\x20\n\x0b\n\x04\x04\x0c\x02\
    \0\x12\x03_#4\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03_#)\n\x0c\n\x05\x04\
    \x0c\x02\0\x01\x12\x03_*/\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03_23\n\n\n\
    \x02\x04\r\x12\x04a\0d\x01\n\n\n\x03\x04\r\x01\x12\x03a\x08\x15\n\x0b\n\
    \x04\x04\r\x02\0\x12\x03b\x02\x1a\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03b\
    \x02\x08\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03b\t\x15\n\x0c\n\x05\x04\r\
    \x02\0\x03\x12\x03b\x18\x19\n\x0b\n\x04\x04\r\x02\x01\x12\x03c\x02\x1a\n\
    \x0c\n\x05\x04\r\x02\x01\x05\x12\x03c\x02\x07\n\x0c\n\x05\x04\r\x02\x01\
    \x01\x12\x03c\x08\x15\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03c\x18\x19\n\n\
    \n\x02\x04\x0e\x12\x04f\0j\x01\n\n\n\x03\x04\x0e\x01\x12\x03f\x08\x16\n\
    \x0b\n\x04\x04\x0e\x02\0\x12\x03g\x02\x13\n\x0c\n\x05\x04\x0e\x02\0\x05\
    \x12\x03g\x02\x08\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03g\t\x0e\n\x0c\n\
    \x05\x04\x0e\x02\0\x03\x12\x03g\x11\x12\n\x0b\n\x04\x04\x0e\x02\x01\x12\
    \x03h\x02\"\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03h\x02\n\n\x0c\n\x05\
    \x04\x0e\x02\x01\x06\x12\x03h\x0b\x15\n\x0c\n\x05\x04\x0e\x02\x01\x01\
    \x12\x03h\x16\x1d\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03h\x20!\n9\n\x04\
    \x04\x0e\x02\x02\x12\x03i\x02\x16\",\x20Will\x20be\x20equal\x20to\x20new\
    _slot_size\x20if\x20success.\n\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03i\
    \x02\x07\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03i\x08\x11\n\x0c\n\x05\
    \x04\x0e\x02\x02\x03\x12\x03i\x14\x15\n\n\n\x02\x04\x0f\x12\x04l\0n\x01\
    \n\n\n\x03\x04\x0f\x01\x12\x03l\x08\x19\n\x0b\n\x04\x04\x0f\x02\0\x12\
    \x03m\x02\x1a\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03m\x02\x08\n\x0c\n\x05\
    \x04\x0f\x02\0\x01\x12\x03m\t\x15\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03m\
    \x18\x19\n\n\n\x02\x04\x10\x12\x04p\0s\x01\n\n\n\x03\x04\x10\x01\x12\x03\
    p\x08\x1a\n\x0b\n\x04\x04\x10\x02\0\x12\x03q\x02\x13\n\x0c\n\x05\x04\x10\
    \x02\0\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03q\t\x0e\
    \n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03q\x11\x12\n\x0b\n\x04\x04\x10\x02\
    \x01\x12\x03r\x02\"\n\x0c\n\x05\x04\x10\x02\x01\x04\x12\x03r\x02\n\n\x0c\
    \n\x05\x04\x10\x02\x01\x06\x12\x03r\x0b\x15\n\x0c\n\x05\x04\x10\x02\x01\
    \x01\x12\x03r\x16\x1d\n\x0c\n\x05\x04\x10\x02\x01\x03\x12\x03r\x20!\n\
    \x0b\n\x02\x04\x11\x12\x05u\0\x80\x01\x01\n\n\n\x03\x04\x11\x01\x12\x03u\
    \x08\x0f\n\x0c\n\x04\x04\x11\x08\0\x12\x04v\x02\x7f\x03\n\x0c\n\x05\x04\
    \x11\x08\0\x01\x12\x03v\x08\x0f\n\x0b\n\x04\x04\x11\x02\0\x12\x03w\x04\
    \x19\n\x0c\n\x05\x04\x11\x02\0\x06\x12\x03w\x04\x0f\n\x0c\n\x05\x04\x11\
    \x02\0\x01\x12\x03w\x10\x14\n\x0c\n\x05\x04\x11\x02\0\x03\x12\x03w\x17\
    \x18\n\x0b\n\x04\x04\x11\x02\x01\x12\x03x\x040\n\x0c\n\x05\x04\x11\x02\
    \x01\x06\x12\x03x\x04\x1a\n\x0c\n\x05\x04\x11\x02\x01\x01\x12\x03x\x1b+\
    \n\x0c\n\x05\x04\x11\x02\x01\x03\x12\x03x./\n\x0b\n\x04\x04\x11\x02\x02\
    \x12\x03y\x042\n\x0c\n\x05\x04\x11\x02\x02\x06\x12\x03y\x04\x1b\n\x0c\n\
    \x05\x04\x11\x02\x02\x01\x12\x03y\x1c-\n\x0c\n\x05\x04\x11\x02\x02\x03\
    \x12\x03y01\n\x0b\n\x04\x04\x11\x02\x03\x12\x03z\x04(\n\x0c\n\x05\x04\
    \x11\x02\x03\x06\x12\x03z\x04\x16\n\x0c\n\x05\x04\x11\x02\x03\x01\x12\
    \x03z\x17#\n\x0c\n\x05\x04\x11\x02\x03\x03\x12\x03z&'\n\x0b\n\x04\x04\
    \x11\x02\x04\x12\x03{\x040\n\x0c\n\x05\x04\x11\x02\x04\x06\x12\x03{\x04\
    \x1a\n\x0c\n\x05\x04\x11\x02\x04\x01\x12\x03{\x1b+\n\x0c\n\x05\x04\x11\
    \x02\x04\x03\x12\x03{./\n\x0b\n\x04\x04\x11\x02\x05\x12\x03|\x042\n\x0c\
    \n\x05\x04\x11\x02\x05\x06\x12\x03|\x04\x1b\n\x0c\n\x05\x04\x11\x02\x05\
    \x01\x12\x03|\x1c-\n\x0c\n\x05\x04\x11\x02\x05\x03\x12\x03|01\n\x0b\n\
    \x04\x04\x11\x02\x06\x12\x03}\x04\x1d\n\x0c\n\x05\x04\x11\x02\x06\x06\
    \x12\x03}\x04\x11\n\x0c\n\x05\x04\x11\x02\x06\x01\x12\x03}\x12\x18\n\x0c\
    \n\x05\x04\x11\x02\x06\x03\x12\x03}\x1b\x1c\n\x0b\n\x04\x04\x11\x02\x07\
    \x12\x03~\x04&\n\x0c\n\x05\x04\x11\x02\x07\x06\x12\x03~\x04\x15\n\x0c\n\
    \x05\x04\x11\x02\x07\x01\x12\x03~\x16!\n\x0c\n\x05\x04\x11\x02\x07\x03\
    \x12\x03~$%\n\x0c\n\x02\x04\x12\x12\x06\x82\x01\0\x8d\x01\x01\n\x0b\n\
    \x03\x04\x12\x01\x12\x04\x82\x01\x08\x10\n\x0e\n\x04\x04\x12\x08\0\x12\
    \x06\x83\x01\x02\x8c\x01\x03\n\r\n\x05\x04\x12\x08\0\x01\x12\x04\x83\x01\
    \x08\x10\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x84\x01\x04\x1a\n\r\n\x05\x04\
    \x12\x02\0\x06\x12\x04\x84\x01\x04\x10\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\x84\x01\x11\x15\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x84\x01\x18\x19\
    \n\x0c\n\x04\x04\x12\x02\x01\x12\x04\x85\x01\x041\n\r\n\x05\x04\x12\x02\
    \x01\x06\x12\x04\x85\x01\x04\x1b\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \x85\x01\x1c,\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x85\x01/0\n\x0c\n\
    \x04\x04\x12\x02\x02\x12\x04\x86\x01\x043\n\r\n\x05\x04\x12\x02\x02\x06\
    \x12\x04\x86\x01\x04\x1c\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x86\x01\
    \x1d.\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\x86\x0112\n\x0c\n\x04\x04\
    \x12\x02\x03\x12\x04\x87\x01\x04)\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\
    \x87\x01\x04\x17\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\x87\x01\x18$\n\r\
    \n\x05\x04\x12\x02\x03\x03\x12\x04\x87\x01'(\n\x0c\n\x04\x04\x12\x02\x04\
    \x12\x04\x88\x01\x041\n\r\n\x05\x04\x12\x02\x04\x06\x12\x04\x88\x01\x04\
    \x1b\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\x88\x01\x1c,\n\r\n\x05\x04\
    \x12\x02\x04\x03\x12\x04\x88\x01/0\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\
    \x89\x01\x043\n\r\n\x05\x04\x12\x02\x05\x06\x12\x04\x89\x01\x04\x1c\n\r\
    \n\x05\x04\x12\x02\x05\x01\x12\x04\x89\x01\x1d.\n\r\n\x05\x04\x12\x02\
    \x05\x03\x12\x04\x89\x0112\n\x0c\n\x04\x04\x12\x02\x06\x12\x04\x8a\x01\
    \x04\x1e\n\r\n\x05\x04\x12\x02\x06\x06\x12\x04\x8a\x01\x04\x12\n\r\n\x05\
    \x04\x12\x02\x06\x01\x12\x04\x8a\x01\x13\x19\n\r\n\x05\x04\x12\x02\x06\
    \x03\x12\x04\x8a\x01\x1c\x1d\n\x0c\n\x04\x04\x12\x02\x07\x12\x04\x8b\x01\
    \x04'\n\r\n\x05\x04\x12\x02\x07\x06\x12\x04\x8b\x01\x04\x16\n\r\n\x05\
    \x04\x12\x02\x07\x01\x12\x04\x8b\x01\x17\"\n\r\n\x05\x04\x12\x02\x07\x03\
    \x12\x04\x8b\x01%&\nY\n\x02\x04\x13\x12\x06\x91\x01\0\x96\x01\x01\x1aK\
    \x20These\x20messages\x20are\x20carried\x20on\x20Subspace\x20channels\
    \x20published\x20by\n\x20the\x20server.\n\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\x91\x01\x08\x13\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x92\x01\x02\x12\n\
    \r\n\x05\x04\x13\x02\0\x05\x12\x04\x92\x01\x02\x08\n\r\n\x05\x04\x13\x02\
    \0\x01\x12\x04\x92\x01\t\r\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x92\x01\
    \x10\x11\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x93\x01\x02\x16\n\r\n\x05\
    \x04\x13\x02\x01\x05\x12\x04\x93\x01\x02\x07\n\r\n\x05\x04\x13\x02\x01\
    \x01\x12\x04\x93\x01\x08\x11\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x93\
    \x01\x14\x15\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x94\x01\x02\x16\n\r\n\
    \x05\x04\x13\x02\x02\x05\x12\x04\x94\x01\x02\x07\n\r\n\x05\x04\x13\x02\
    \x02\x01\x12\x04\x94\x01\x08\x11\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\
    \x94\x01\x14\x15\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\x95\x01\x02\x11\n\r\
    \n\x05\x04\x13\x02\x03\x05\x12\x04\x95\x01\x02\x07\n\r\n\x05\x04\x13\x02\
    \x03\x01\x12\x04\x95\x01\x08\x0c\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\
    \x95\x01\x0f\x10\nL\n\x02\x04\x14\x12\x06\x99\x01\0\x9c\x01\x01\x1a>\x20\
    This\x20is\x20published\x20to\x20the\x20/subspace/ChannelDirectory\x20ch\
    annel.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x99\x01\x08\x18\n\x0c\n\x04\x04\
    \x14\x02\0\x12\x04\x9a\x01\x02\x17\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\
    \x9a\x01\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x9a\x01\t\x12\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\x9a\x01\x15\x16\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\x9b\x01\x02$\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x9b\x01\
    \x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\x9b\x01\x0b\x16\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\x9b\x01\x17\x1f\n\r\n\x05\x04\x14\x02\x01\
    \x03\x12\x04\x9b\x01\"#\n\x0c\n\x02\x04\x15\x12\x06\x9e\x01\0\xa6\x01\
    \x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x9e\x01\x08\x14\n\x0c\n\x04\x04\x15\
    \x02\0\x12\x04\x9f\x01\x02\x1a\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x9f\
    \x01\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x9f\x01\t\x15\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\x9f\x01\x18\x19\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xa0\x01\x02\x18\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xa0\x01\
    \x02\x07\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xa0\x01\x08\x13\n\r\n\x05\
    \x04\x15\x02\x01\x03\x12\x04\xa0\x01\x16\x17\n\x0c\n\x04\x04\x15\x02\x02\
    \x12\x04\xa1\x01\x02\x1b\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xa1\x01\
    \x02\x07\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xa1\x01\x08\x16\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\xa1\x01\x19\x1a\n\x0c\n\x04\x04\x15\x02\x03\
    \x12\x04\xa2\x01\x02\x16\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xa2\x01\
    \x02\x07\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xa2\x01\x08\x11\n\r\n\x05\
    \x04\x15\x02\x03\x03\x12\x04\xa2\x01\x14\x15\n\x0c\n\x04\x04\x15\x02\x04\
    \x12\x04\xa3\x01\x02\x16\n\r\n\x05\x04\x15\x02\x04\x05\x12\x04\xa3\x01\
    \x02\x07\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xa3\x01\x08\x11\n\r\n\x05\
    \x04\x15\x02\x04\x03\x12\x04\xa3\x01\x14\x15\n\x0c\n\x04\x04\x15\x02\x05\
    \x12\x04\xa4\x01\x02\x15\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\xa4\x01\
    \x02\x07\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xa4\x01\x08\x10\n\r\n\x05\
    \x04\x15\x02\x05\x03\x12\x04\xa4\x01\x13\x14\n\x0c\n\x04\x04\x15\x02\x06\
    \x12\x04\xa5\x01\x02\x15\n\r\n\x05\x04\x15\x02\x06\x05\x12\x04\xa5\x01\
    \x02\x07\n\r\n\x05\x04\x15\x02\x06\x01\x12\x04\xa5\x01\x08\x10\n\r\n\x05\
    \x04\x15\x02\x06\x03\x12\x04\xa5\x01\x13\x14\nF\n\x02\x04\x16\x12\x06\
    \xa9\x01\0\xad\x01\x01\x1a8\x20This\x20is\x20published\x20to\x20the\x20/\
    subspace/Statistics\x20channel.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xa9\
    \x01\x08\x12\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xaa\x01\x02\x17\n\r\n\x05\
    \x04\x16\x02\0\x05\x12\x04\xaa\x01\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\
    \x12\x04\xaa\x01\t\x12\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xaa\x01\x15\
    \x16\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xab\x01\x02\x16\n\r\n\x05\x04\
    \x16\x02\x01\x05\x12\x04\xab\x01\x02\x07\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\xab\x01\x08\x11\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xab\x01\
    \x14\x15\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xac\x01\x02%\n\r\n\x05\x04\
    \x16\x02\x02\x04\x12\x04\xac\x01\x02\n\n\r\n\x05\x04\x16\x02\x02\x06\x12\
    \x04\xac\x01\x0b\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xac\x01\x18\
    \x20\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xac\x01#$\n\x0c\n\x02\x04\x17\
    \x12\x06\xaf\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xaf\x01\
    \x08\x16\n#\n\x04\x04\x17\x02\0\x12\x04\xb0\x01\x02\x17\"\x15\x20In\x20h\
    ost\x20byte\x20order.\n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xb0\x01\x02\
    \x07\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xb0\x01\x08\x12\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xb0\x01\x15\x16\n#\n\x04\x04\x17\x02\x01\x12\x04\
    \xb1\x01\x02\x11\"\x15\x20In\x20host\x20byte\x20order.\n\n\r\n\x05\x04\
    \x17\x02\x01\x05\x12\x04\xb1\x01\x02\x07\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\xb1\x01\x08\x0c\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xb1\x01\
    \x0f\x10\np\n\x02\x04\x18\x12\x06\xb6\x01\0\xbb\x01\x01\x1ab\x20This\x20\
    is\x20sent\x20over\x20the\x20connected\x20channel\x20TCP\x20bridge\x20wh\
    en\x20the\n\x20bridged\x20subscription\x20is\x20successful.\n\n\x0b\n\
    \x03\x04\x18\x01\x12\x04\xb6\x01\x08\x12\n\x0c\n\x04\x04\x18\x02\0\x12\
    \x04\xb7\x01\x02\x1a\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xb7\x01\x02\x08\
    \n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb7\x01\t\x15\n\r\n\x05\x04\x18\x02\
    \0\x03\x12\x04\xb7\x01\x18\x19\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xb8\
    \x01\x02\x16\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xb8\x01\x02\x07\n\r\n\
    \x05\x04\x18\x02\x01\x01\x12\x04\xb8\x01\x08\x11\n\r\n\x05\x04\x18\x02\
    \x01\x03\x12\x04\xb8\x01\x14\x15\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xb9\
    \x01\x02\x16\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xb9\x01\x02\x07\n\r\n\
    \x05\x04\x18\x02\x02\x01\x12\x04\xb9\x01\x08\x11\n\r\n\x05\x04\x18\x02\
    \x02\x03\x12\x04\xb9\x01\x14\x15\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xba\
    \x01\x02\x14\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xba\x01\x02\x06\n\r\n\
    \x05\x04\x18\x02\x03\x01\x12\x04\xba\x01\x07\x0f\n\r\n\x05\x04\x18\x02\
    \x03\x03\x12\x04\xba\x01\x12\x13\n.\n\x02\x04\x19\x12\x06\xbe\x01\0\xd8\
    \x01\x01\x1a\x20\x20This\x20message\x20is\x20sent\x20over\x20UDP.\n\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\xbe\x01\x08\x11\nA\n\x04\x04\x19\x03\0\
    \x12\x04\xc0\x01\x02,\x1a3\x20Ask\x20which\x20server\x20is\x20publishing\
    \x20the\x20named\x20channel.\n\n\r\n\x05\x04\x19\x03\0\x01\x12\x04\xc0\
    \x01\n\x0f\n\x0e\n\x06\x04\x19\x03\0\x02\0\x12\x04\xc0\x01\x12*\n\x0f\n\
    \x07\x04\x19\x03\0\x02\0\x05\x12\x04\xc0\x01\x12\x18\n\x0f\n\x07\x04\x19\
    \x03\0\x02\0\x01\x12\x04\xc0\x01\x19%\n\x0f\n\x07\x04\x19\x03\0\x02\0\
    \x03\x12\x04\xc0\x01()\nD\n\x04\x04\x19\x03\x01\x12\x06\xc3\x01\x02\xc6\
    \x01\x03\x1a4\x20Advertise\x20that\x20the\x20sender\x20is\x20publishing\
    \x20a\x20channel.\n\n\r\n\x05\x04\x19\x03\x01\x01\x12\x04\xc3\x01\n\x13\
    \n\x0e\n\x06\x04\x19\x03\x01\x02\0\x12\x04\xc4\x01\x04\x1c\n\x0f\n\x07\
    \x04\x19\x03\x01\x02\0\x05\x12\x04\xc4\x01\x04\n\n\x0f\n\x07\x04\x19\x03\
    \x01\x02\0\x01\x12\x04\xc4\x01\x0b\x17\n\x0f\n\x07\x04\x19\x03\x01\x02\0\
    \x03\x12\x04\xc4\x01\x1a\x1b\n\x0e\n\x06\x04\x19\x03\x01\x02\x01\x12\x04\
    \xc5\x01\x04\x16\n\x0f\n\x07\x04\x19\x03\x01\x02\x01\x05\x12\x04\xc5\x01\
    \x04\x08\n\x0f\n\x07\x04\x19\x03\x01\x02\x01\x01\x12\x04\xc5\x01\t\x11\n\
    \x0f\n\x07\x04\x19\x03\x01\x02\x01\x03\x12\x04\xc5\x01\x14\x15\ns\n\x04\
    \x04\x19\x03\x02\x12\x06\xca\x01\x02\xce\x01\x03\x1ac\x20Subscribe\x20to\
    \x20the\x20given\x20channel.\x20\x20The\x20sender\x20is\x20listening\n\
    \x20on\x20the\x20address\x20specified\x20in\x20'receiver'.\n\n\r\n\x05\
    \x04\x19\x03\x02\x01\x12\x04\xca\x01\n\x13\n\x0e\n\x06\x04\x19\x03\x02\
    \x02\0\x12\x04\xcb\x01\x04\x1c\n\x0f\n\x07\x04\x19\x03\x02\x02\0\x05\x12\
    \x04\xcb\x01\x04\n\n\x0f\n\x07\x04\x19\x03\x02\x02\0\x01\x12\x04\xcb\x01\
    \x0b\x17\n\x0f\n\x07\x04\x19\x03\x02\x02\0\x03\x12\x04\xcb\x01\x1a\x1b\n\
    \x0e\n\x06\x04\x19\x03\x02\x02\x01\x12\x04\xcc\x01\x04\x20\n\x0f\n\x07\
    \x04\x19\x03\x02\x02\x01\x06\x12\x04\xcc\x01\x04\x12\n\x0f\n\x07\x04\x19\
    \x03\x02\x02\x01\x01\x12\x04\xcc\x01\x13\x1b\n\x0f\n\x07\x04\x19\x03\x02\
    \x02\x01\x03\x12\x04\xcc\x01\x1e\x1f\n\x0e\n\x06\x04\x19\x03\x02\x02\x02\
    \x12\x04\xcd\x01\x04\x16\n\x0f\n\x07\x04\x19\x03\x02\x02\x02\x05\x12\x04\
    \xcd\x01\x04\x08\n\x0f\n\x07\x04\x19\x03\x02\x02\x02\x01\x12\x04\xcd\x01\
    \t\x11\n\x0f\n\x07\x04\x19\x03\x02\x02\x02\x03\x12\x04\xcd\x01\x14\x15\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xd0\x01\x02\x17\n\r\n\x05\x04\x19\x02\0\
    \x05\x12\x04\xd0\x01\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xd0\x01\
    \t\x12\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xd0\x01\x15\x16\n*\n\x04\x04\
    \x19\x02\x01\x12\x04\xd1\x01\x02\x11\"\x1c\x20UDP\x20port\x20I'm\x20list\
    ening\x20on.\n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xd1\x01\x02\x07\n\r\
    \n\x05\x04\x19\x02\x01\x01\x12\x04\xd1\x01\x08\x0c\n\r\n\x05\x04\x19\x02\
    \x01\x03\x12\x04\xd1\x01\x0f\x10\n\x0e\n\x04\x04\x19\x08\0\x12\x06\xd3\
    \x01\x02\xd7\x01\x03\n\r\n\x05\x04\x19\x08\0\x01\x12\x04\xd3\x01\x08\x0c\
    \n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xd4\x01\x04\x14\n\r\n\x05\x04\x19\
    \x02\x02\x06\x12\x04\xd4\x01\x04\t\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\
    \xd4\x01\n\x0f\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xd4\x01\x12\x13\n\
    \x0c\n\x04\x04\x19\x02\x03\x12\x04\xd5\x01\x04\x1c\n\r\n\x05\x04\x19\x02\
    \x03\x06\x12\x04\xd5\x01\x04\r\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xd5\
    \x01\x0e\x17\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xd5\x01\x1a\x1b\n\x0c\
    \n\x04\x04\x19\x02\x04\x12\x04\xd6\x01\x04\x1c\n\r\n\x05\x04\x19\x02\x04\
    \x06\x12\x04\xd6\x01\x04\r\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\xd6\x01\
    \x0e\x17\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xd6\x01\x1a\x1bb\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(29);
            messages.push(InitRequest::generated_message_descriptor_data());
            messages.push(InitResponse::generated_message_descriptor_data());
            messages.push(BufferInfo::generated_message_descriptor_data());
            messages.push(CreatePublisherRequest::generated_message_descriptor_data());
            messages.push(CreatePublisherResponse::generated_message_descriptor_data());
            messages.push(CreateSubscriberRequest::generated_message_descriptor_data());
            messages.push(CreateSubscriberResponse::generated_message_descriptor_data());
            messages.push(GetTriggersRequest::generated_message_descriptor_data());
            messages.push(GetTriggersResponse::generated_message_descriptor_data());
            messages.push(RemovePublisherRequest::generated_message_descriptor_data());
            messages.push(RemovePublisherResponse::generated_message_descriptor_data());
            messages.push(RemoveSubscriberRequest::generated_message_descriptor_data());
            messages.push(RemoveSubscriberResponse::generated_message_descriptor_data());
            messages.push(ResizeRequest::generated_message_descriptor_data());
            messages.push(ResizeResponse::generated_message_descriptor_data());
            messages.push(GetBuffersRequest::generated_message_descriptor_data());
            messages.push(GetBuffersResponse::generated_message_descriptor_data());
            messages.push(Request::generated_message_descriptor_data());
            messages.push(Response::generated_message_descriptor_data());
            messages.push(ChannelInfo::generated_message_descriptor_data());
            messages.push(ChannelDirectory::generated_message_descriptor_data());
            messages.push(ChannelStats::generated_message_descriptor_data());
            messages.push(Statistics::generated_message_descriptor_data());
            messages.push(ChannelAddress::generated_message_descriptor_data());
            messages.push(Subscribed::generated_message_descriptor_data());
            messages.push(Discovery::generated_message_descriptor_data());
            messages.push(discovery::Query::generated_message_descriptor_data());
            messages.push(discovery::Advertise::generated_message_descriptor_data());
            messages.push(discovery::Subscribe::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
